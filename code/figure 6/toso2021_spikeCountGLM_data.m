%% check 'main.m' has run (and run it if not)
toso2021_maincheck;

%% GLM settings
distro = 'normal';
glm_win = t_set(t1_mode_idx);
glm_str = sprintf('t%i',glm_win);

%% preallocation
spkcounts = struct();
fractions = struct();

%% ROI settings

% initialization
glm_roi = struct();
glm_roi_lbl = struct();

% roi definitions
glm_roi.preInit = [-glm_win,0];
glm_roi.postInit = [0,glm_win];
glm_roi.preS1Onset = [-glm_win,0];
glm_roi.postS1Onset = [0,glm_win];
glm_roi.preS1Offset = [-glm_win,0];
glm_roi.postS1Offset = [0,glm_win];
glm_roi.preS2Onset = [-glm_win,0];
glm_roi.postS2Onset = [0,glm_win];
glm_roi.preS2Offset = [-glm_win,0];
glm_roi.postS2Offset = [0,glm_win];
glm_roi.preGoCue = [-glm_win,0];
glm_roi.postGoCue = [0,glm_win];
glm_roi.aroundReaction = glm_roi.postGoCue + glm_win;
glm_roi.aroundChoice = glm_roi.postGoCue + glm_win * 2;

% roi labels
glm_roi_lbl.preInit = 'Pre-initiation';
glm_roi_lbl.postInit = 'Post-initiation';
glm_roi_lbl.preS1Onset = 'Pre-S1 onset';
glm_roi_lbl.postS1Onset = 'Post-S1 onset';
glm_roi_lbl.preS1Offset = 'Pre-S1 offset';
glm_roi_lbl.postS1Offset = 'Post-S1 offset';
glm_roi_lbl.preS2Onset = 'Pre-S2 onset';
glm_roi_lbl.postS2Onset = 'Post-S2 onset';
glm_roi_lbl.preS2Offset = 'Pre-S2 offset';
glm_roi_lbl.postS2Offset = 'Post-S2 offset';
glm_roi_lbl.preGoCue = 'Pre-go cue';
glm_roi_lbl.postGoCue = 'Post-go cue';
glm_roi_lbl.aroundReaction = '~Reaction';
glm_roi_lbl.aroundChoice = '~Choice';

% epoch parsing
epochs = fieldnames(glm_roi);
n_epochs = numel(epochs);

%% construct response

% iterate through neurons
for nn = 1 : n_neurons
    progressreport(nn,n_neurons,'fetching spike counts');
    neuron_flags = data.NeuronNumb == flagged_neurons(nn);
    
    % flag trials for the current condition
    trial_flags = ...
        valid_flags & ...
        neuron_flags;
    if sum(trial_flags) == 0
        continue;
    end
    
    % fetch spike counts & compute spike rates
    spike_counts = data.FR(trial_flags,:)';
    n_trials = sum(trial_flags);
    
    % around approach spike rates
    if isfield(glm_roi,'aroundInitMov')
        alignment_onset = ...
            repmat(pre_init_padding,n_trials,1);
        alignment_flags = ...
            padded_time >= alignment_onset + glm_roi.aroundInitMov(1) & ...
            padded_time < alignment_onset + glm_roi.aroundInitMov(2);
        chunk_flags = alignment_flags;
        spkcounts_aroundInitMov = spike_counts;
        spkcounts_aroundInitMov(~alignment_flags') = nan;
        spkcounts_aroundInitMov = ...
            reshape(spkcounts_aroundInitMov(chunk_flags'),[glm_win,n_trials])';
        spkcounts.aroundInitMov(trial_flags) = nansum(spkcounts_aroundInitMov,2);
    end
    
    % pre initiation spike rates
    if isfield(glm_roi,'preInit')
        alignment_onset = ...
            repmat(pre_init_padding,n_trials,1);
        alignment_flags = ...
            padded_time >= alignment_onset + glm_roi.preInit(1) & ...
            padded_time < alignment_onset + glm_roi.preInit(2);
        chunk_flags = alignment_flags;
        spkcounts_preInit = spike_counts;
        spkcounts_preInit(~alignment_flags') = nan;
        spkcounts_preInit = ...
            reshape(spkcounts_preInit(chunk_flags'),[glm_win,n_trials])';
        spkcounts.preInit(trial_flags) = nansum(spkcounts_preInit,2);
    end
    
    % post initiation spike rates
    if isfield(glm_roi,'postInit')
        alignment_onset = ...
            repmat(pre_init_padding,n_trials,1);
        alignment_flags = ...
            padded_time >= alignment_onset + glm_roi.postInit(1) & ...
            padded_time < alignment_onset + glm_roi.postInit(2);
        chunk_flags = alignment_flags;
        spkcounts_postInit = spike_counts;
        spkcounts_postInit(~alignment_flags') = nan;
        spkcounts_postInit = ...
            reshape(spkcounts_postInit(chunk_flags'),[glm_win,n_trials])';
        spkcounts.postInit(trial_flags) = nansum(spkcounts_postInit,2);
    end
    
    % pre-S1 onset spike rates
    if isfield(glm_roi,'preS1Onset')
        alignment_onset = ...
            pre_init_padding + ...
            pre_s1_delay(trial_flags);
        alignment_flags = ...
            padded_time >= alignment_onset + glm_roi.preS1Onset(1) & ...
            padded_time < alignment_onset + glm_roi.preS1Onset(2);
        chunk_flags = alignment_flags;
        spkcounts_preS1Onset = spike_counts;
        spkcounts_preS1Onset(~alignment_flags') = nan;
        spkcounts_preS1Onset = ...
            reshape(spkcounts_preS1Onset(chunk_flags'),[glm_win,n_trials])';
        spkcounts.preS1Onset(trial_flags) = nansum(spkcounts_preS1Onset,2);
    end
    
    % post-S1 onset spike rates
    alignment_onset = ...
        pre_init_padding + ...
        pre_s1_delay(trial_flags);
    alignment_flags = ...
        padded_time >= alignment_onset + glm_roi.postS1Onset(1) & ...
        padded_time < alignment_onset + t1(trial_flags);
    chunk_flags = ...
        padded_time >= alignment_onset + glm_roi.postS1Onset(1) & ...
        padded_time < alignment_onset + glm_roi.postS1Onset(2);
    spkcounts_postS1Onset = spike_counts;
    spkcounts_postS1Onset(~alignment_flags') = nan;
    spkcounts_postS1Onset = ...
        reshape(spkcounts_postS1Onset(chunk_flags'),[glm_win,n_trials])';
    
    % pre-S1 offset spike rates
    alignment_onset = ...
        pre_init_padding + ...
        pre_s1_delay(trial_flags) + ...
        t1(trial_flags);
    alignment_flags = ...
        padded_time >= alignment_onset - t1(trial_flags) & ...
        padded_time < alignment_onset + glm_roi.preS1Offset(2);
    chunk_flags = ...
        padded_time >= alignment_onset + glm_roi.preS1Offset(1) & ...
        padded_time < alignment_onset + glm_roi.preS1Offset(2);
    spkcounts_preS1Offset = spike_counts;
    spkcounts_preS1Offset(~alignment_flags') = nan;
    spkcounts_preS1Offset = ...
        reshape(spkcounts_preS1Offset(chunk_flags'),[glm_win,n_trials])';
    
    % post-S1 offset spike rates
    if isfield(glm_roi,'postS1Offset')
        alignment_onset = ...
            pre_init_padding + ...
            pre_s1_delay(trial_flags) + ...
            t1(trial_flags);
        alignment_flags = ...
            padded_time >= alignment_onset + glm_roi.postS1Offset(1) & ...
            padded_time < alignment_onset + glm_roi.postS1Offset(2);
        chunk_flags = alignment_flags;
        spkcounts_postS1Offset = spike_counts;
        spkcounts_postS1Offset(~alignment_flags') = nan;
        spkcounts_postS1Offset = ...
            reshape(spkcounts_postS1Offset(chunk_flags'),[glm_win,n_trials])';
        spkcounts.postS1Offset(trial_flags) = nansum(spkcounts_postS1Offset,2);
    end
    
    % pre-S2 onset spike rates
    if isfield(glm_roi,'preS2Onset')
        alignment_onset = ...
            pre_init_padding + ...
            pre_s1_delay(trial_flags) + ...
            t1(trial_flags) + ...
            isi;
        alignment_flags = ...
            padded_time >= alignment_onset + glm_roi.preS2Onset(1) & ...
            padded_time < alignment_onset + glm_roi.preS2Onset(2);
        chunk_flags = alignment_flags;
        spkcounts_preS2Onset = spike_counts;
        spkcounts_preS2Onset(~alignment_flags') = nan;
        spkcounts_preS2Onset = ...
            reshape(spkcounts_preS2Onset(chunk_flags'),[glm_win,n_trials])';
        spkcounts.preS2Onset(trial_flags) = nansum(spkcounts_preS2Onset,2);
    end
    
    % post-S2 onset spike rates
    alignment_onset = ...
        pre_init_padding + ...
        pre_s1_delay(trial_flags) + ...
        t1(trial_flags) + ...
        isi;
    alignment_flags = ...
        padded_time >= alignment_onset + glm_roi.postS2Onset(1) & ...
        padded_time < alignment_onset + t2(trial_flags);
    chunk_flags = ...
        padded_time >= alignment_onset + glm_roi.postS2Onset(1) & ...
        padded_time < alignment_onset + glm_roi.postS2Onset(2);
    spkcounts_postS2Onset = spike_counts;
    spkcounts_postS2Onset(~alignment_flags') = nan;
    spkcounts_postS2Onset = ...
        reshape(spkcounts_postS2Onset(chunk_flags'),[glm_win,n_trials])';
    
    % pre-S2 offset spike rates
    alignment_onset = ...
        pre_init_padding + ...
        pre_s1_delay(trial_flags) + ...
        t1(trial_flags) + ...
        isi + ...
        t2(trial_flags);
    alignment_flags = ...
        padded_time >= alignment_onset - t2(trial_flags) & ...
        padded_time < alignment_onset + glm_roi.preS2Offset(2);
    chunk_flags = ...
        padded_time >= alignment_onset + glm_roi.preS2Offset(1) & ...
        padded_time < alignment_onset + glm_roi.preS2Offset(2);
    spkcounts_preS2Offset = spike_counts;
    spkcounts_preS2Offset(~alignment_flags') = nan;
    spkcounts_preS2Offset = ...
        reshape(spkcounts_preS2Offset(chunk_flags'),[glm_win,n_trials])';
    
    % post-S2 offset spike rates
    if isfield(glm_roi,'postS2Offset')
        alignment_onset = ...
            pre_init_padding + ...
            pre_s1_delay(trial_flags) + ...
            t1(trial_flags) + ...
            isi + ...
            t2(trial_flags);
        alignment_flags = ...
            padded_time >= alignment_onset + glm_roi.postS2Offset(1) & ...
            padded_time < alignment_onset + glm_roi.postS2Offset(2);
        chunk_flags = alignment_flags;
        spkcounts_postS2Offset = spike_counts;
        spkcounts_postS2Offset(~alignment_flags') = nan;
        spkcounts_postS2Offset = ...
            reshape(spkcounts_postS2Offset(chunk_flags'),[glm_win,n_trials])';
        spkcounts.postS2Offset(trial_flags) = nansum(spkcounts_postS2Offset,2);
    end
    
    % pre-go spike rates
    if isfield(glm_roi,'preGoCue')
        alignment_onset = ...
            pre_init_padding + ...
            pre_s1_delay(trial_flags) + ...
            t1(trial_flags) + ...
            isi + ...
            t2(trial_flags) + ...
            post_s2_delay;
        alignment_flags = ...
            padded_time >= alignment_onset + glm_roi.preGoCue(1) & ...
            padded_time < alignment_onset + glm_roi.preGoCue(2);
        chunk_flags = alignment_flags;
        spkcounts_preGoCue = spike_counts;
        spkcounts_preGoCue(~alignment_flags') = nan;
        spkcounts_preGoCue = ...
            reshape(spkcounts_preGoCue(chunk_flags'),[glm_win,n_trials])';
        spkcounts.preGoCue(trial_flags) = nansum(spkcounts_preGoCue,2);
    end
    
    % post-go spike rates
    if isfield(glm_roi,'postGoCue')
        alignment_onset = ...
            pre_init_padding + ...
            pre_s1_delay(trial_flags) + ...
            t1(trial_flags) + ...
            isi + ...
            t2(trial_flags) + ...
            post_s2_delay;
        alignment_flags = ...
            padded_time >= alignment_onset + glm_roi.postGoCue(1) & ...
            padded_time < alignment_onset + glm_roi.postGoCue(2);
        chunk_flags = alignment_flags;
        spkcounts_postGoCue = spike_counts;
        spkcounts_postGoCue(~alignment_flags') = nan;
        spkcounts_postGoCue = ...
            reshape(spkcounts_postGoCue(chunk_flags'),[glm_win,n_trials])';
        spkcounts.postGoCue(trial_flags) = nansum(spkcounts_postGoCue,2);
    end
    
    % around reaction spike rates
    if isfield(glm_roi,'aroundReaction')
        alignment_onset = ...
            pre_init_padding + ...
            pre_s1_delay(trial_flags) + ...
            t1(trial_flags) + ...
            isi + ...
            t2(trial_flags) + ...
            post_s2_delay;
        alignment_flags = ...
            padded_time >= alignment_onset + glm_roi.aroundReaction(1) & ...
            padded_time < alignment_onset + glm_roi.aroundReaction(2);
        chunk_flags = alignment_flags;
        spkcounts_aroundReaction = spike_counts;
        spkcounts_aroundReaction(~alignment_flags') = nan;
        spkcounts_aroundReaction = ...
            reshape(spkcounts_aroundReaction(chunk_flags'),[glm_win,n_trials])';
        spkcounts.aroundReaction(trial_flags) = nansum(spkcounts_aroundReaction,2);
    end
    
    % around choice spike rates
    if isfield(glm_roi,'aroundChoice')
        alignment_onset = ...
            pre_init_padding + ...
            pre_s1_delay(trial_flags) + ...
            t1(trial_flags) + ...
            isi + ...
            t2(trial_flags) + ...
            post_s2_delay;
        alignment_flags = ...
            padded_time >= alignment_onset + glm_roi.aroundChoice(1) & ...
            padded_time < alignment_onset + glm_roi.aroundChoice(2);
        chunk_flags = alignment_flags;
        spkcounts_aroundChoice = spike_counts;
        spkcounts_aroundChoice(~alignment_flags') = nan;
        spkcounts_aroundChoice = ...
            reshape(spkcounts_aroundChoice(chunk_flags'),[glm_win,n_trials])';
        spkcounts.aroundChoice(trial_flags) = nansum(spkcounts_aroundChoice,2);
    end
    
    % store average spike rates
    spkcounts.postS1Onset(trial_flags) = nansum(spkcounts_postS1Onset,2);
    spkcounts.preS1Offset(trial_flags) = nansum(spkcounts_preS1Offset,2);
    spkcounts.postS2Onset(trial_flags) = nansum(spkcounts_postS2Onset,2);
    spkcounts.preS2Offset(trial_flags) = nansum(spkcounts_preS2Offset,2);
end

%% spike count GLM

% design matrix
design = [prev_choice,prev_correct,s1,s2,d1,d2,choice,correct,trial_idcs];
n_regressors = size(design,2);
n_coefficients = n_regressors + 1;

% feature normalization
zdesign = (design - nanmean(design)) ./ nanstd(design);

% preallocation
betas = struct();
pvals_raw = struct();
residuals = struct();
rsquared = struct();

% iterate through epochs
for ee = 1 : n_epochs
    epoch = epochs{ee};
    
    % preallocation
    betas.(epoch) = zeros(n_neurons,n_coefficients);
    pvals_raw.(epoch) = zeros(n_neurons,n_coefficients);
    residuals.(epoch) = nan(n_total_trials,1);
    
    % duration selection
    t1_flags = t1 >= glm_win * ...
        ismember(epoch,{'postS1Onset','preS1Offset'});
    t2_flags = t2 >= glm_win * ...
        ismember(epoch,{'postS2Onset','preS2Offset'});

    % iterate through neurons
    for nn = 1 : n_neurons
        progressreport(nn,n_neurons,...
            sprintf('fitting neuron-wise GLMs (%s)',epoch));
        neuron_flags = data.NeuronNumb == flagged_neurons(nn);
        trial_flags = ...
            valid_flags & ...
            neuron_flags & ...
            t1_flags & ...
            t2_flags;
        n_flagged_trials = sum(trial_flags);
        if n_flagged_trials <= 1
            continue;
        end
        
        % fit GLM
        X = zdesign(trial_flags,:);
        y = spkcounts.(epoch)(trial_flags);
        opts = statset('robust','off');
        mdl = fitglm(X,y,'linear',...
            'predictorvars',{'prevchoice','prevreward',s1_lbl,s2_lbl,d1_lbl,d2_lbl,'choice','reward','trial#'},...
            'distribution',distro,...
            'intercept',true,...
            'options',opts);
        
        % caching
        betas.(epoch)(nn,:) = mdl.Coefficients.Estimate;
        pvals_raw.(epoch)(nn,:) = mdl.Coefficients.pValue;
        residuals.(epoch)(trial_flags) = mdl.Residuals.Raw;
        rsquared.(epoch).normal(nn) = mdl.Rsquared.Ordinary;
    end
end

%% benjamini-hochberg correction for multiple comparisons

% initialization
pvals_corrected = struct();

% iterate through neurons
for nn = 1 : n_neurons
    progressreport(nn,n_neurons,'p-value correction');
    
    % preallocation
    pvals = nan(n_epochs,n_coefficients);
    
    % iterate through epochs
    for ee = 1 : n_epochs
        epoch = epochs{ee};
        pvals(ee,:) = pvals_raw.(epoch)(nn,:);
    end
    
    % benjamini-hochberg correction for multiple comparisons
    [~,k] = sort(pvals);
    pvals = pvals .* n_epochs ./ k;
    
    % iterate through epochs
    for ee = 1 : n_epochs
        epoch = epochs{ee};
        pvals_corrected.(epoch)(nn,:) = pvals(ee,:);
    end
end

%% plot proportion of significantly modulated neurons

% coefficient selection
coeffs2plot = mdl.CoefficientNames(2:end-1);
n_coeffs2plot = numel(coeffs2plot);
coeffs2highlight = coeffs2plot;

% uncomment below to only highlight specific task factors
% coeffs2highlight = {...
%     'T1',...
%     'T2',...
%     'I1',...
%     'I2',...
%     'choice',...
%     };

% enact factor selection
coeffs2highlight_flags = ismember(coeffs2plot,coeffs2highlight);
coeffs2highlight_idcs = find(coeffs2highlight_flags);

% bar width settings
epoch_span = 3 / 4;
barwidth = epoch_span / n_coeffs2plot;

% figure initialization
fig = figure(figopt,...
    'windowstate','maximized',...
    ...'position',[150,125,1500,825],...
    'name',sprintf('GLM_significance_crossEpochs_%s_%i_%s',...
    distro,glm_win,strrep([coeffs2highlight{:}],'_','')),...
    'color',[1,1,1]*1);

% alignments
alignments = {...
    '','Initiation','',...
    '','S1 onset','',...
    '','S1 offset','',...
    '','S2 onset','',...
    '','S2 offset','',...
    '','Go cue','',...
    };
n_alignments = numel(alignments);

% axes initialization
yymax = .25;
yylim = [-1,1]*yymax+[-1,1]*.05*yymax*2;
yytick = -yymax : .05 : yymax;
yyticklabel = num2cell(abs(round(yytick,2)));
yyticklabel(~ismember(yytick,[0,[-1,1]*yymax,[-1,1]*.05])) = {''};
axes(axesopt.default,...
    'plotboxaspectratio',[3,1,1],...
    'color','none',...
    'ticklength',axesopt.default.ticklength*1/3,...
    'xlim',[1,n_epochs]+[-1,1]*.5,...
    'xtick',unique([(1:2:(n_alignments*2-4));...
    (1:2:(n_alignments*2-4))+[-1;1]*.05714*n_epochs])+.5,...
    'xticklabel',alignments,...
    'xticklabelrotation',0,...
    'xcolor','k',...
    'ylim',yylim,...
    'ytick',yytick,...
    'yticklabel',yyticklabel,...
    'clipping','off',...
    'layer','bottom');
title(sprintf('Spike counts in %i ms ~ %s(\\phi(\\betaX))',...
    glm_win,capitalize(distro)));
xlabel('Task event');
ylabel({'P(significant regression coefficients)',...
    'down-modulated                up-modulated'},...
    'verticalalignment','bottom');

% significance settings
alphas = [.05,.01];
n_alphas = numel(alphas);

% reference lines
plot(xlim,[1,1]*0,'-k',...
    'linewidth',1.5);

% pseudo-legend (stimulus epochs)
s1epoch_idcs = ...
    [find(ismember(epochs,'postS1Onset')),...
    find(ismember(epochs,'preS1Offset'))];
plot(s1epoch_idcs+[-1,1]*.5,[1,1]*yymax,...
    'linestyle','-',...
    'linewidth',3,...
    'color',stim_clrs(1,:));
text(mean(s1epoch_idcs),yymax*1.025,'S1 presentation',...
    'color',stim_clrs(1,:),...
    'fontsize',12,...
    'horizontalalignment','center',...
    'verticalalignment','bottom');
s2epoch_idcs = ...
    [find(ismember(epochs,'postS2Onset')),...
    find(ismember(epochs,'preS2Offset'))];
plot(s2epoch_idcs+[-1,1]*.5,[1,1]*yymax,...
    'linestyle','-',...
    'linewidth',3,...
    'color',stim_clrs(2,:));
text(mean(s2epoch_idcs),yymax*1.025,'S2 presentation',...
    'color',stim_clrs(2,:),...
    'fontsize',12,...
    'horizontalalignment','center',...
    'verticalalignment','bottom');

% graphical object preallocation
h = gobjects((n_coefficients-2)*n_epochs*2*n_alphas,1);
h_idx = 1;

% iterate through epochs
for ee = 1 : n_epochs
    epoch = epochs{ee};
    
    % epoch delimeter
    p = plot([1,1]*ee+1/2,[-1.1,1]*yymax,...
        'color','k',...
        'linestyle','--');
    uistack(p,'bottom');
    
    % pseudo x-tick label
    text(ee,-yymax*1,glm_roi_lbl.(epoch),...
        'horizontalalignment','center',...
        'color','k',...
        'fontsize',10);
    
    % compute horizontal offsets
    x_offsets = ee + (0 : n_coeffs2plot - 1) * barwidth + ...
        barwidth / 2 - epoch_span / 2;
    
    % iterate through alphas
    for aa = 1 : n_alphas
        
        % preallocation
        P = nan(n_coeffs2plot,2);
        
        % iterate through coefficients
        for bb = 1 : n_coeffs2plot
            coeff_lbl = coeffs2plot{bb};
            coeff_idx = find(ismember(mdl.CoefficientNames,coeff_lbl));
            coeff_lbl = strrep(coeff_lbl,'#','');
            coeff_str = strrep(lower(coeff_lbl),'_','');
            coeff_clrs = eval([coeff_str,'_clrs']);
            x = x_offsets(bb);
            
            % significance flags
            significant_flags = pvals_corrected.(epoch)(:,coeff_idx) <= alphas(aa);

            % iterate through signs
            signs = [-1,1];
            for ss = 1 : 2
                sign_flags = sign(betas.(epoch)(:,coeff_idx)) == signs(ss);
                n = sum(significant_flags & sign_flags);
                p = n / n_neurons;
                
                % store proportion for later use
                fractions.(glm_str).(epoch).(coeff_lbl)(aa,ss) = p;
                
                % handle color according to modulation direction
                if signs(ss) == -1
                    facecolor = coeff_clrs(1,:);
                else
                    facecolor = coeff_clrs(end,:);
                end
                if ~coeffs2highlight_flags(bb)
                    facecolor = [1,1,1] * .75;
                    edgecolor = 'none';
                else
                    edgecolor = 'k';
                end
                if alphas(aa) == max(alphas)
                    n_fadedcolors = 5;
                    clrs = colorlerp([facecolor;[1,1,1]],n_fadedcolors);
                    facecolor = clrs(end-1,:);
                end
                xpatch = x + [-1,1,1,-1] / 2 * barwidth * 1;
                ypatch = p * signs(ss) .* [0,0,1,1];
                patch(xpatch,ypatch,'k',...
                    'edgecolor','none',...
                    'facecolor',facecolor,...
                    'facealpha',1,...
                    'linewidth',1.5);
                
                P(bb,ss) = p;
                if alphas(aa) == max(alphas) && bb == n_coeffs2plot
                    xstairs = ...
                        [x_offsets(coeffs2highlight_idcs(1)),...
                        x_offsets(coeffs2highlight_idcs),...
                        x_offsets(coeffs2highlight_idcs(end)),...
                        x_offsets(coeffs2highlight_idcs(end))+barwidth]-barwidth/2;
                    ystairs = [0;...
                        P(coeffs2highlight_idcs,ss);...
                        P(coeffs2highlight_idcs(end),ss)*[1;0]] * signs(ss);
                    h(h_idx) = stairs(xstairs,ystairs,...
                        'color','k',...
                        'linewidth',1.5);
                    h_idx = h_idx + 1;
                end
                
                % regressor lines
                if ee == 1 && alphas(aa) == max(alphas) && signs(ss) == 1
                    offset = numel(coeff_str)*.025*yymax;
                    p = plot(x*[1,1],[p,yymax],...
                        'linestyle','-',...
                        'color','k');
                    uistack(p,'bottom');
                end
            end
            
            % pseudo-legend (significance)
            if ee == 1 && bb == 1
                aspectratio = pbaspect;
                xpatch = 1.5 + [-1,1,1,-1] * .25 / (1 + (alphas(aa) == min(alphas))) - ...
                    .125 * (alphas(aa) == min(alphas));
                ypatch = -yymax + [-1,-1,1,1] / 2 * barwidth * ...
                    range(ylim) / range(xlim) * aspectratio(1) / aspectratio(2) + ...
                    diff(yytick(1:2));
                if alphas(aa) == min(alphas)
                    clr = [0,0,0];
                else
                    clrs = colorlerp([[0,0,0];[1,1,1]],n_fadedcolors);
                    clr = clrs(end-1,:);
                end
                patch(xpatch,ypatch,clr,...
                    'facealpha',1,...
                    'linewidth',1.5);
                if alphas(aa) == max(alphas)
                    text(mean(xpatch),mean(ypatch)+.01,'\alpha',...
                        'color','k',...
                        'fontsize',12,...
                        'fontweight','normal',...
                        'horizontalalignment','center',...
                        'verticalalignment','bottom');
                end
                if alphas(aa) == max(alphas)
                    horzalignment = 'left';
                    xalpha = max(xpatch) + .06;
                else
                    horzalignment = 'right';
                    xalpha = min(xpatch) - .06;
                end
                text(xalpha,mean(ypatch)+.0025,sprintf('%.2f',alphas(aa)),...
                    'color','k',...
                    'fontsize',8,...
                    'horizontalalignment',horzalignment,...
                    'verticalalignment','middle');
            end
        end
    end
end

% ui resorting
uistack(h(isgraphics(h)),'top');

% regressor labels
regressor_lbls = strrep(coeffs2plot,'_','');
regressor_lbls = strrep(regressor_lbls,'I1','I1_{t}');
regressor_lbls = strrep(regressor_lbls,'T1','T1_{t}');
regressor_lbls = strrep(regressor_lbls,'I2','I2_{t}');
regressor_lbls = strrep(regressor_lbls,'T2','T2_{t}');
regressor_lbls = strrep(regressor_lbls,'prevchoice','C_{t-1}');
regressor_lbls = strrep(regressor_lbls,'choice','C_{t}');
regressor_lbls = strrep(regressor_lbls,'prevreward','R_{t-1}');
regressor_lbls = strrep(regressor_lbls,'reward','R_{t}');

% correlation matrix
ax_mult = 1;
ax_sig = axes(axesopt.default,...
    'position',[.12,.7,.075,.085],...
    'ticklength',axesopt.default.ticklength,...
    'nextplot','add',...
    'fontsize',8,...
    'box','on',...
    'xtick',1:n_coeffs2plot,...
    'ytick',1:n_coeffs2plot,...
    'xticklabel',regressor_lbls,...
    'yticklabel',regressor_lbls,...
    'xticklabelrotation',90,...
    'xaxislocation','bottom',...
    'yaxislocation','right',...
    'ydir','reverse',...
    'plotboxaspectratio',[1,1,1],...
    'xlimspec','tight',...
    'ylimspec','tight',...
    'xcolor','k',...
    'ycolor','k');
title('Regressors',...
    'fontweight','normal',...
    'fontsize',10);

% compute correlation matrix
trial_flags = ...
    valid_flags & ...
    unique_flags & ...
    ~any(isnan(design),2);
sig = corr(design(trial_flags,1:end-1));

% plot correlation matrix
imagesc(sig);

% color bar
clrbar = colorbar;
clrbar.Ticks = unique([0,1]);
clrlabel.string = {'Correlation','coefficient'};
clrlabel.fontsize = ax_sig.FontSize;
clrlabel.rotation = 270;
clrlabel.position = [6,clrbar.Label.Position(2),0];
set(clrbar,...
    axesopt.colorbar,...
    'fontsize',ax_sig.FontSize,...
    'box','on');
set(clrbar.Label,...
    clrlabel);
set(ax_sig,...
    'position',[ax_sig.Position(1),ax_sig.Position(2),...
    .075*ax_mult,.085*ax_mult]);

% bin settings
binspan = [0,15];
n_bins = range(binspan) + 1;
binedges = linspace(binspan(1),binspan(2),n_bins);

% iterate through epochs
for ee = 1 : n_epochs
    epoch = epochs{ee};
    
    % spike count distributions
    width = .085 * 1;
    height = width;
    x0 = (ee - 1) / n_epochs * .75 + .125;
    y0 = .05;
    axes(axesopt.default,...
        'position',[x0,y0,width,height],...
        'ticklength',axesopt.default.ticklength*2,...
        'fontsize',8,...
        'linewidth',1,...
        'plotboxaspectratio',[1,1,1],...
        'nextplot','add',...
        'xlim',binspan,...
        'xtick',binspan,...
        'ylimspec','tight',...
        'box','off',...
        'xcolor','k',...
        'ycolor','none');
    xlabel("Spike count");
    
    % compute spike count distribution
    bincounts = histcounts(spkcounts.(epoch)(valid_flags),...
        'binedges',binedges);
    bincounts = bincounts / nansum(bincounts);
    
    % plot spike count distribution
    clrs = colorlerp([[0,0,0];[1,1,1]],n_fadedcolors);
    clr = clrs(end-1,:);
    histogram(...
        'binedges',binedges,...
        'bincounts',bincounts,...
        'facealpha',1,...
        'edgecolor','none',...
        'facecolor',clr,...
        'linewidth',1.5);
end

% save figure
if want2save
    svg_file = fullfile(panel_path,[fig.Name,'.svg']);
    print(fig,svg_file,'-dsvg','-painters');
end

%% highlight coefficients of interest

% coefficient selection
coeffsets2plot = {...
    'T1','T2';...
    'I1','I2',...
    };
[n_coeffsets,n_coeffsperset] = size(coeffsets2plot);
setyymax = .3 ./ [1,2];
setlabels = {'Duration','Intensity'};

% iterate through coeff set
for ss = 1 : n_coeffsets
    
    % figure initialization
    fig = figure(figopt,...
        'name',sprintf('GLM_significance_%s_%i_%s',...
        distro,glm_win,lower(setlabels{ss})),...
        'position',[400,200,750,500],...
        'color',[1,1,1]*1);
    
    % axes initialization
    yymax = setyymax(ss);
    yylim = [0,1]*yymax+[-1,1]*.05*yymax;
    yytick = unique([0,[0,1]*yymax,[0,1]*.05,[0,1]*.01]);
    yyticklabel = num2cell(abs(round(yytick,2)));
    yyticklabel(~ismember(yytick,[0,[0,1]*yymax])) = {''};
    axes(axesopt.default,...
        'plotboxaspectratio',[2,1,1],...
        'color','none',...
        'ticklength',axesopt.default.ticklength*.58,...
        'xlim',[1,n_epochs]+[-1,1]*.75,...
        'xtick',1:n_epochs,...
        'xticklabel',struct2cell(glm_roi_lbl),...
        'xticklabelrotation',45,...
        'ylim',yylim,...
        'ytick',yytick,...
        'yticklabel',yyticklabel,...
        'clipping','off',...
        'layer','bottom');
    ylabel(sprintf('P(significant %s coefficients)',lower(setlabels{ss})));
    
    % color settings
    s1_feature_str = lower(strrep(coeffsets2plot{ss,1},'_',''));
    s2_feature_str = lower(strrep(coeffsets2plot{ss,2},'_',''));
    stim_feature_clrs = stim_clrs;
    
    % pseudo-legend (stimulus epochs)
    s1epoch_idcs = ...
        [find(ismember(epochs,'postS1Onset')),...
        find(ismember(epochs,'preS1Offset'))];
    plot(s1epoch_idcs,[1,1]*yymax,...
        'linestyle','-',...
        'linewidth',3,...
        'color',stim_feature_clrs(1,:));
    text(mean(s1epoch_idcs),yymax*1.025,...
        sprintf('%s presentation','S1'),...
        'color',stim_feature_clrs(1,:),...
        'fontsize',12,...
        'horizontalalignment','center',...
        'verticalalignment','bottom');
    s2epoch_idcs = ...
        [find(ismember(epochs,'postS2Onset')),...
        find(ismember(epochs,'preS2Offset'))];
    plot(s2epoch_idcs,[1,1]*yymax,...
        'linestyle','-',...
        'linewidth',3,...
        'color',stim_feature_clrs(2,:));
    text(mean(s2epoch_idcs),yymax*1.025,...
        sprintf('%s presentation','S2'),...
        'color',stim_feature_clrs(2,:),...
        'fontsize',12,...
        'horizontalalignment','center',...
        'verticalalignment','bottom');

    % preallocation
    P = nan(n_epochs,n_alphas,n_coeffsperset);
    
    % iterate through coefficients
    for bb = 1 : n_coeffsperset
        coeff_lbl = coeffsets2plot{ss,bb};
        coeff_idx = find(ismember(mdl.CoefficientNames,coeff_lbl));
        coeff_lbl = strrep(coeff_lbl,'#','');
        coeff_str = strrep(lower(coeff_lbl),'_','');
        coeff_clrs = eval([coeff_str,'_clrs']);
        
        % iterate through alphas
        for aa = 1 : n_alphas
            
            % iterate through epochs
            for ee = 1 : n_epochs
                epoch = epochs{ee};
                P(ee,aa,bb) = sum(...
                    fractions.(glm_str).(epoch).(coeff_lbl)(aa,:));
            end
            
            % plot sign-agnostic proportion through epochs
            stairs(1:n_epochs,P(:,aa,bb),...
                'color',stim_feature_clrs(bb,:),...
                'linewidth',1.5,...
                'linestyle',repmat('-',1,1+(alphas(aa)==max(alphas))));
        end
    end
    
    % iterate through alphas
    for aa = 1 : n_alphas
        if alphas(aa) == min(alphas)
            clr = [0,0,0];
        else
            clrs = colorlerp([[0,0,0];[1,1,1]],n_fadedcolors);
            clr = clrs(end-1,:);
        end
        
        % iterate through epochs
        for ee = 1 : n_epochs
            text(ee,max(ylim)*(1.025+aa*.05),...
                sprintf('%.2f',P(ee,aa,2)/P(ee,aa,1)),...
                'color',clr);
        end
    end
    
    % legend
    leg_h = gobjects(n_alphas,1);
    for aa = 1 : n_alphas
        leg_h(aa) = plot([1,2]*max(xlim)*1.5,[1,2]*max(ylim)*1.5,...
            'color','k',...
            'linewidth',1.5,...
            'linestyle',repmat('-',1,1+(alphas(aa)==max(alphas))));
    end
    leg_str = arrayfun(@(x)sprintf('\\alpha = %.2f %s %s',x,...
        strrep(coeffsets2plot{ss,1},'_',''),...
        strrep(coeffsets2plot{ss,2},'_','')),...
        alphas,...
        'uniformoutput',false);
    legend(leg_h,leg_str,...
        'location','northwest',...
        'color','k',...
        'fontweight','normal',...
        'box','off');
    
    % save figure
    if want2save
        svg_file = fullfile(panel_path,[fig.Name,'.svg']);
        print(fig,svg_file,'-dsvg','-painters');
    end
end