%% initialization
if ~exist('data','var')
    toso2021_wrapper;
end

%% notes
% beta depends on time units (s or ms), and firing rate;
% rho and beta are redundant;
% stereoptypy is a circular criterion for the point of decodability

%% seed fixing
% rng(0);

%% tensor settings
N = 200;     	% neurons
N_clus = 25;    % neurons per cluster
K = 100;        % trials
S = 100;        % simulations
P = 4;          % number of partitions with which to assess stereotypy

%% time settings
dt = 75;
ti = 0;
tf = 1000;
t = ti : tf;
T = numel(t);
t_padded = ti - dt/2 : tf + dt/2;
t_idcs = 1 : T;
t_units = 1e3;

%% "ramping" criteria

% "monotonocity" criteria
rho_monotonocity_cutoff = .5;
% beta_monotonocity_cutoff = .05;     % what they say they do in the methods
beta_monotonocity_cutoff = .004;	% what's in their code
pval_monotonocity_cutoff = .05;

% stereotypy criteria
rho_stereotypy_cutoff = .5;
pval_stereotypy_cutoff = .01;

%% model settings

% model parameters
gamma_ranges = [...
    [5,5,10]; ...
    [0,100,5]; ...
    [7,7,10]; ...
    [0,100,7]];
lambda_ranges = [...
    [0,0]; ...
    [0,0]; ...
    [0,tf*2]; ...
    [0,tf*2]];
M = size(lambda_ranges,1);

% model labels
model_labels = cell(M,1);
for mm = 1 : M
    model_labels{mm} = sprintf([...
        '\\gamma\\in[%i,%i]','\\newline',...
        '\\lambda\\in[%i,%i]'],...
        gamma_ranges(mm,1),gamma_ranges(mm,2),...
        lambda_ranges(mm,1),lambda_ranges(mm,2));
end
model_labels = {...
    '\gamma=\gamma_0\newline\lambda=\lambda_0';...
    '\gamma\sim\newline\lambda=\lambda_0';...
    '\gamma=\gamma_0\newline\lambda\sim';...
    '\gamma\sim\newline\lambda\sim';...
    };
disp(model_labels);

%% model simulations

% preallocation
P_TR_RAMP = nan(T,T,S,M);
P_TR_NON = nan(T,T,S,M);
MAP_ramp = nan(T,S,M);
MAP_non = nan(T,S,M);
MU_ramp = nan(T,S,M);
MU_non = nan(T,S,M);
MED_ramp = nan(T,S,M);
MED_non = nan(T,S,M);
SD_ramp = nan(T,S,M);
SD_non = nan(T,S,M);
IQR_ramp = nan(T,S,M);
IQR_non = nan(T,S,M);
MUS = nan(N_clus*2,S,M);
SIGMAS = nan(N_clus*2,S,M);
GAMMAS = nan(N_clus*2,S,M);
LAMBDAS = nan(N_clus*2,S,M);
MEAN_FR = nan(N_clus*2,S,M);
SELECTED_RAMP_FLAGS = false(N_clus*2,S,M);
ALL_RAMP_FLAGS = false(N,S,M);
P_RAMP = nan(S,M);

% all unit indices
all_idcs = 1 : N;

close all

% iterate through models
for mm = 1 : M
    
    % iterate through simulations
    for ss = 1 : S
        progressreport(ss,S,'simulating')
        
        %% model parameters
%         if mm == 1 || mm == M
        mus = sort(unifrnd(ti,tf,N,1));
%         else
%             mus = [repmat(ti,floor(N/2),1);repmat(tf,ceil(N/2),1)];
%         end
        gammas = clamp(exprnd(gamma_ranges(mm,3),N,1),...
            gamma_ranges(mm,1),gamma_ranges(mm,2));
        lambdas = clamp(exprnd(1/3*(tf-ti),N,1),...
            lambda_ranges(mm,1),lambda_ranges(mm,2));
%         sigmas = abs(normrnd(.25,.05,N,1)) * (tf - ti);
        sigmas = ones(N,1) * .25 * (tf - ti);
        
        %% generate fake data
        
        % preallocation
        X = nan(T,N,K);
        R = nan(T,N,K);
        
        % baseline firing rate
        bsl_fr = 1;
        
        % iterate through neurons
        for nn = 1 : N
            for kk = 1 : K
                X(:,nn,kk) = bsl_fr + generativerate(...
                    t,gammas(nn),mus(nn),lambdas(nn),sigmas(nn));
                x_padded = bsl_fr + generativerate(...
                    t_padded,gammas(nn),mus(nn),lambdas(nn),sigmas(nn));
                dur_padded = range(t_padded) / t_units;
                [~,ts] = poissonprocess(x_padded,dur_padded);
                spk_times = ts * t_units + t_padded(1);
                spk_counts = histcounts(spk_times,'binedges',t_padded);
                r_padded = movsum(spk_counts,dt) / (dt / t_units);
                t_flags = t_padded >= ti & t_padded < tf + 1;
                R(:,nn,kk) = r_padded(t_flags);
            end
        end
        
        % !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
%         R = X;
        % !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        
        %% compute cross-trial averages
        x = nanmean(X,3);
        r = nanmean(R,3);
        
        %% compute correlation coefficients
        rhos_monotonocity = nan(N,1);
        
        % iterate through neurons
        for nn = 1 : N
            rhos_monotonocity(nn) = corr(t_idcs',r(:,nn));
        end
        
        %% perform linear regression
        mdls = cell(N,1);
        pvals_monotonocity = nan(N,1);
        betas_monotonocity = nan(N,1);
        
        % iterate through neurons
        for nn = 1 : N
            mdls{nn} = fitlm(t_idcs,r(:,nn));
            p = polyfit(t_idcs,r(:,nn)',1);
            pvals_monotonocity(nn) = mdls{nn}.Coefficients.pValue(end);
            betas_monotonocity(nn) = p(1);
        end
        
        %% stereotypy assessment
        k = floor(K / P);
        shuffled_trial_idcs = randperm(K,K);
        
        % preallocation
        r_partitions = nan(T,N,P);
        rhos_stereotypy = nan(N,P);
        pvals_stereotypy = nan(N,P);
        
        % iterate through partitions
        for pp = 1 : P
            partition_idcs = shuffled_trial_idcs((1 : k) + (pp - 1) * k);
            r_partitions(:,:,pp) = nanmean(R(:,:,partition_idcs),3);
        end
        
        % compute reference
        r_ref = nanmean(r_partitions,3);
        
        % iterate through partitions
        for pp = 1 : P
            
            % iterate through neurons
            for nn = 1 : N
                [rhos,pvals] = corrcoef(r_ref(:,nn),r_partitions(:,nn,pp));
                rhos_stereotypy(nn,pp) = rhos(1,2);
                pvals_stereotypy(nn,pp) = pvals(1,2);
            end
        end
        
        %% neuron selection
        
        % flag "monotonic" neurons
        monotonicity_flags = ...
            abs(rhos_monotonocity) > rho_monotonocity_cutoff & ...
            abs(betas_monotonocity) > beta_monotonocity_cutoff & ...
            pvals_monotonocity <= pval_monotonocity_cutoff;
        
        % flag stereotypical neurons
        stereotypy_flags = ...
            mean(rhos_stereotypy > rho_stereotypy_cutoff,2) == 1 & ...
            mean(pvals_stereotypy < pval_stereotypy_cutoff,2) == 1;
        
        % flag "ramping" neurons
        ramp_flags = ...
            monotonicity_flags & ...
            stereotypy_flags;
        
        %% naive bayes decoder
        train_flags = ismember(1:K,randperm(K,round(K/2)));
        tensor_ramp = cat(3,...
            nanmean(R(:,ramp_flags,train_flags),3),...
            nanmean(R(:,ramp_flags,~train_flags),3));
        tensor_non = cat(3,...
            nanmean(R(:,~ramp_flags,train_flags),3),...
            nanmean(R(:,~ramp_flags,~train_flags),3));
        
        % enforce equal numbers of neurons on both clusters
        n_ramp = sum(ramp_flags);
        n_non = sum(~ramp_flags);
        n = min(n_ramp,n_non);
        all_ramp_idcs = all_idcs(ramp_flags);
        all_non_idcs = all_idcs(~ramp_flags);
        selected_ramp_idcs = sort(randperm(n_ramp,N_clus));
        selected_non_idcs = sort(randperm(n_non,N_clus));
        selected_idcs = sort([...
            all_ramp_idcs(selected_ramp_idcs),...
            all_non_idcs(selected_non_idcs)]);
        tensor_ramp = tensor_ramp(:,selected_ramp_idcs,:);
        tensor_non = tensor_non(:,selected_non_idcs,:);
        
        % decoding options
        opt = struct();
        opt.n_xpoints = 100;
        opt.time = t;
        opt.train.trial_idcs = 1;
        opt.train.n_trials = numel(opt.train.trial_idcs);
        opt.test.trial_idcs = 2;
        opt.test.n_trials = numel(opt.test.trial_idcs);
        opt.assumepoissonmdl = true;
        opt.verbose = false;
        
        % preallocation
        P_tR_ramp = naivebayestimedecoder(tensor_ramp,opt);
        P_tR_non = naivebayestimedecoder(tensor_non,opt);
        
        %% compute decoding statistics
        
        % preallocation
        mu_ramp = nan(T,1);
        mu_non = nan(T,1);
        sd_ramp = nan(T,1);
        sd_non = nan(T,1);
        
        % iterate through time points
        for tt = 1 : T
            mu_ramp(tt) = P_tR_ramp(tt,:) * t';
            mu_non(tt) = P_tR_non(tt,:) * t';
            sd_ramp(tt) = sqrt(P_tR_ramp(tt,:) * (mu_ramp(tt) - t') .^ 2);
            sd_non(tt) = sqrt(P_tR_non(tt,:) * (mu_non(tt) - t') .^ 2);
        end
        
        % compute posterior median
        median_flags_ramp = [false(T,1),diff(cumsum(P_tR_ramp,2) > .5,1,2) == 1];
        median_flags_non = [false(T,1),diff(cumsum(P_tR_non,2) > .5,1,2) == 1];
        [~,median_idcs_ramp] = max(median_flags_ramp,[],2);
        [~,median_idcs_non] = max(median_flags_non,[],2);
        med_ramp = t(median_idcs_ramp);
        med_non = t(median_idcs_non);
        
        % compute posterior IQR
        q25_flags_ramp = [false(T,1),diff(cumsum(P_tR_ramp,2) > .25,1,2) == 1];
        q75_flags_ramp = [false(T,1),diff(cumsum(P_tR_ramp,2) > .75,1,2) == 1];
        q25_flags_non = [false(T,1),diff(cumsum(P_tR_non,2) > .25,1,2) == 1];
        q75_flags_non = [false(T,1),diff(cumsum(P_tR_non,2) > .75,1,2) == 1];
        [~,q25_idcs_ramp] = max(q25_flags_ramp,[],2);
        [~,q75_idcs_ramp] = max(q75_flags_ramp,[],2);
        [~,q25_idcs_non] = max(q25_flags_non,[],2);
        [~,q75_idcs_non] = max(q75_flags_non,[],2);
        iqr_ramp = t(q75_idcs_ramp) - t(q25_idcs_ramp);
        iqr_non = t(q75_idcs_non) - t(q25_idcs_non);
        
        % compute MAP
        [~,mode_idcs_ramp] = max(P_tR_ramp,[],2);
        [~,mode_idcs_non] = max(P_tR_non,[],2);
        map_ramp = t(mode_idcs_ramp);
        map_non = t(mode_idcs_non);
        
        %% store current simulation
        P_TR_RAMP(:,:,ss,mm) = P_tR_ramp;
        P_TR_NON(:,:,ss,mm) = P_tR_non;
        MAP_ramp(:,ss,mm) = map_ramp;
        MAP_non(:,ss,mm) = map_non;
        MU_ramp(:,ss,mm) = mu_ramp;
        MU_non(:,ss,mm) = mu_non;
        MED_ramp(:,ss,mm) = med_ramp;
        MED_non(:,ss,mm) = med_non;
        SD_ramp(:,ss,mm) = sd_ramp;
        SD_non(:,ss,mm) = sd_non;
        IQR_ramp(:,ss,mm) = iqr_ramp;
        IQR_non(:,ss,mm) = iqr_non;
        MUS(:,ss,mm) = mus(selected_idcs);
        SIGMAS(:,ss,mm) = sigmas(selected_idcs);
        GAMMAS(:,ss,mm) = gammas(selected_idcs);
        LAMBDAS(:,ss,mm) = lambdas(selected_idcs);
        MEAN_FR(:,ss,mm) = mean(r(:,selected_idcs),1);
        SELECTED_RAMP_FLAGS(:,ss,mm) = ramp_flags(selected_idcs);
        ALL_RAMP_FLAGS(:,ss,mm) = ramp_flags;
        P_RAMP(ss,mm) = nanmean(ramp_flags);
        
        %% skip plotting single-run stuff if it's not the last run
        if ss < S
            continue;
        end
        
        %% tiling
        
        % figure initialization
        figure(figopt,...
            'windowstyle','docked',...
            'name',sprintf('tiling_%i',mm));
        
        % axes initialization
        n_rows = 2;
        n_cols = 3;
        n_sps = n_rows * n_cols;
        sps = gobjects(n_sps,1);
        for ii = 1 : n_sps
            sps(ii) = subplot(n_rows,n_cols,ii);
            xlabel(sps(ii),'Time (s)');
            ylabel(sps(ii),'Neuron #');
        end
        set(sps,...
            axesopt.default,...
            'xlim',[ti,tf],...
            'colormap',hot(2^8),...
            'layer','top',...
            'tickdir','out',...
            'nextplot','add',...
            'plotboxaspectratio',[1,1,1],...
            'linewidth',2,...
            'fontsize',12,...
            'ticklength',[1,1]*.025);
        set(sps(1+[0,n_cols]),...
            'ylim',[1,N_clus*2],...
            'ytick',[1,N_clus*2]);
        set(sps([2;3]+[0,n_cols]),...
            'ylim',[1,N_clus],...
            'ytick',[1,N_clus])
        title(sps(1),'All');
        title(sps(2),'Ramps');
        title(sps(3),'Non-ramps');
        
        % normalization
        z = zscore(r);
        
        % color limits
        r_clim = [min(r,[],'all'),max(r,[],'all')];
        z_clim = [-1,1] .* max(abs(z),[],'all');
        
        % plot rate rasters
        imagesc(sps(1),t,[1,N_clus*2],r(:,selected_idcs)',r_clim);
        imagesc(sps(2),t,[1,N_clus],...
            r(:,all_ramp_idcs(selected_ramp_idcs))',r_clim);
        imagesc(sps(3),t,[1,N_clus],...
            r(:,all_non_idcs(selected_non_idcs))',r_clim);
        
        % plot z-score rasters
        imagesc(sps(4),t,[1,N_clus*2],z(:,selected_idcs)',z_clim);
        imagesc(sps(5),t,[1,N_clus],...
            z(:,all_ramp_idcs(selected_ramp_idcs))',z_clim);
        imagesc(sps(6),t,[1,N_clus],...
            z(:,all_non_idcs(selected_non_idcs))',z_clim);
        %         imagesc(sps(2),t,[1,N],z(:,ramp_flags)',clim);
        %         imagesc(sps(3),t,[1,N],z(:,~ramp_flags)',clim);
        
        % color bar
        %         clrbar = colorbar;
        % %         clrbar.Ticks = unique([0,clim]);
        % %         clrlabel.string = 'Firing rate (z-score)';
        %         clrlabel.string = 'Firing rate (Hz)';
        %         clrlabel.fontsize = axesopt.default.fontsize * 1.1;
        %         clrlabel.rotation = 270;
        %         clrlabel.position = [4,sum(clrbar.Limits)/2,0];
        %         set(clrbar,...
        %             axesopt.colorbar,...
        %             'color','k',...
        %             'fontsize',axesopt.default.fontsize);
        %         set(clrbar.Label,...
        %             'color','k',...
        %             clrlabel);
        
        %% plot posterior averages
        figure(...
            'name',sprintf('posterior_averages_%i',mm),...
            'numbertitle','off',...
            'windowstyle','docked');
        n_rows = 1;
        n_cols = 2;
        sps = gobjects(n_rows,n_cols);
        for rr = 1 : n_rows
            for cc = 1 : n_cols
                sp_idx = cc + (rr - 1) * n_cols;
                sps(rr,cc) = subplot(n_rows,n_cols,sp_idx);
                xlabel(sps(rr,cc),'Real time (ms)');
                ylabel(sps(rr,cc),'Decoded time (ms)');
            end
        end
        set(sps,...
            'xlim',[ti,tf],...
            'ylim',[ti,tf],...
            'xdir','normal',...
            'ydir','normal',...
            'nextplot','add',...
            'plotboxaspectratio',[1,1,1]);
        linkaxes(sps);
        
        % iterate through conditions
        clim = quantile([P_tR_ramp(:);P_tR_non(:)],[.001,.999]);
        
        % ramping posteriors
        title(sps(1),sprintf('Ramping neurons (%i/%i)',sum(ramp_flags),N));
        imagesc(sps(1),[ti,tf],[ti,tf],P_tR_ramp',clim);
        plot(sps(1),xlim(sps(1)),ylim(sps(1)),'-k');
        plot(sps(1),xlim(sps(1)),ylim(sps(1)),'--w');
        
        % non-ramping posteriors
        title(sps(2),sprintf('Non-ramping neurons (%i/%i)',sum(~ramp_flags),N));
        imagesc(sps(2),[ti,tf],[ti,tf],P_tR_non',clim);
        plot(sps(2),xlim(sps(2)),ylim(sps(2)),'-k');
        plot(sps(2),xlim(sps(2)),ylim(sps(2)),'--w');
    end
end

%% parameter distributions

% figure initialization
fig = figure(figopt,...
    'position',[200,200,560,450],...
    'name','ramp_parameter_distributions');

% axes initialization
n_sps = 3;
sps = gobjects(n_sps,1);
for ii = 1 : n_sps
    sps(ii) = subplot(n_sps,1,ii);
    ylabel(sps(ii),'PDF');
end
set(sps,axesopt.default,...
    'plotboxaspectratio',[5,1,1],...
    'ticklength',axesopt.default.ticklength,...
    'xlimspec','tight',...
    'ylimspec','tight',...
    'ytick',0,...
    'clipping','off');
xlabel(sps(1),'\mu (ms)');
xlabel(sps(2),'\lambda (ms)');
xlabel(sps(3),'\gamma');

% model selection
model2plot = M;
mus2plot = MUS(:,:,model2plot);
lambdas2plot = LAMBDAS(:,:,model2plot);
gammas2plot = GAMMAS(:,:,model2plot);
ramps2plot_flags = SELECTED_RAMP_FLAGS(:,:,model2plot);

% bin settings
n_bins = 30;
mu_bounds = [0,tf];
lambda_bounds = [0,tf];
gamma_bounds = [0,30];
mu_edges = linspace(mu_bounds(1),mu_bounds(2),n_bins);
lambda_edges = linspace(lambda_bounds(1),lambda_bounds(2),n_bins);
gamma_edges = linspace(gamma_bounds(1),gamma_bounds(2),n_bins);

% compute parameter distributions
mu_counts_ramp = histcounts(mus2plot(ramps2plot_flags),mu_edges);
mu_counts_non = histcounts(mus2plot(~ramps2plot_flags),mu_edges);
lambda_counts_ramp = histcounts(lambdas2plot(ramps2plot_flags),lambda_edges);
lambda_counts_non = histcounts(lambdas2plot(~ramps2plot_flags),lambda_edges);
gamma_counts_ramp = histcounts(gammas2plot(ramps2plot_flags),gamma_edges);
gamma_counts_non = histcounts(gammas2plot(~ramps2plot_flags),gamma_edges);

% convert to PDF
mu_counts_ramp = mu_counts_ramp ./ nansum(mu_counts_ramp);
mu_counts_non = mu_counts_non ./ nansum(mu_counts_non);
lambda_counts_ramp = lambda_counts_ramp ./ nansum(lambda_counts_ramp);
lambda_counts_non = lambda_counts_non ./ nansum(lambda_counts_non);
gamma_counts_ramp = gamma_counts_ramp ./ nansum(gamma_counts_ramp);
gamma_counts_non = gamma_counts_non ./ nansum(gamma_counts_non);

% convert to CDF
% mu_counts_ramp = cumsum(mu_counts_ramp / sum(mu_counts_ramp));
% mu_counts_non = cumsum(mu_counts_non / sum(mu_counts_non));
% lambda_counts_ramp = cumsum(lambda_counts_ramp / sum(lambda_counts_ramp));
% lambda_counts_non = cumsum(lambda_counts_non / sum(lambda_counts_non));
% gamma_counts_ramp = cumsum(gamma_counts_ramp / sum(gamma_counts_ramp));
% gamma_counts_non = cumsum(gamma_counts_non / sum(gamma_counts_non));

% plot mu distributions
histogram(sps(1),...
    'binedges',mu_edges,...
    'bincounts',mu_counts_non,...
    'facecolor',ramp_clrs(2,:),...
    'edgecolor','none',...
    'facealpha',1,...
    'linewidth',1.5);
histogram(sps(1),...
    'binedges',mu_edges,...
    'bincounts',mu_counts_ramp,...
    'facecolor',ramp_clrs(1,:),...
    'edgecolor','none',...
    'facealpha',1,...
    'linewidth',1.5);
histogram(sps(1),...
    'binedges',mu_edges,...
    'bincounts',mu_counts_non,...
    'facecolor',ramp_clrs(2,:),...
    'edgecolor','none',...
    'facealpha',.5,...
    'linewidth',1.5);
stairs(sps(1),mu_edges,[mu_counts_ramp,mu_counts_ramp(end)],...
    'color','w',...ramp_clrs(1,:),...
    'linewidth',1.5);
% stairs(sps(1),mu_edges,[mu_counts_non,mu_counts_non(end)],...
%     'color','w',...ramp_clrs(2,:),...
%     'linewidth',1.5);

% plot lambda distributions
histogram(sps(2),...
    'binedges',lambda_edges,...
    'bincounts',lambda_counts_non,...
    'facecolor',ramp_clrs(2,:),...
    'edgecolor','none',...
    'facealpha',1,...
    'linewidth',1.5);
histogram(sps(2),...
    'binedges',lambda_edges,...
    'bincounts',lambda_counts_ramp,...
    'facecolor',ramp_clrs(1,:),...
    'edgecolor','none',...
    'facealpha',1,...
    'linewidth',1.5);
histogram(sps(2),...
    'binedges',lambda_edges,...
    'bincounts',lambda_counts_non,...
    'facecolor',ramp_clrs(2,:),...
    'edgecolor','none',...
    'facealpha',.5,...
    'linewidth',1.5);
stairs(sps(2),lambda_edges,[lambda_counts_ramp,lambda_counts_ramp(end)],...
    'color','w',...ramp_clrs(1,:),...
    'linewidth',1.5);
% stairs(sps(2),lambda_edges,[lambda_counts_non,lambda_counts_non(end)],...
%     'color','w',...ramp_clrs(2,:),...
%     'linewidth',1.5);

% plot gamma distributions
histogram(sps(3),...
    'binedges',gamma_edges,...
    'bincounts',gamma_counts_non,...
    'facecolor',ramp_clrs(2,:),...
    'edgecolor','none',...
    'facealpha',1,...
    'linewidth',1.5);
histogram(sps(3),...
    'binedges',gamma_edges,...
    'bincounts',gamma_counts_ramp,...
    'facecolor',ramp_clrs(1,:),...
    'edgecolor','none',...
    'facealpha',1,...
    'linewidth',1.5);
histogram(sps(3),...
    'binedges',gamma_edges,...
    'bincounts',gamma_counts_non,...
    'facecolor',ramp_clrs(2,:),...
    'edgecolor','none',...
    'facealpha',.5,...
    'linewidth',1.5);
stairs(sps(3),gamma_edges,[gamma_counts_ramp,gamma_counts_ramp(end)],...
    'color','w',...ramp_clrs(1,:),...
    'linewidth',1.5);
% stairs(sps(3),gamma_edges,[gamma_counts_non,gamma_counts_non(end)],...
%     'color',ramp_clrs(2,:),...
%     'linewidth',1.5);

% update axes
set(sps(1),...
    'xlim',mu_bounds,...
    'xtick',mu_bounds);
set(sps(2),...
    'xlim',lambda_bounds,...
    'xtick',lambda_bounds);
set(sps(3),...
    'xlim',gamma_bounds,...
    'xtick',gamma_bounds);

% save figure
if want2save
    svg_file = fullfile(panel_path,[fig.Name,'.svg']);
    print(fig,svg_file,'-dsvg','-painters');
end

%% point estimate selection
pthat_str = 'MU';
pthat_ramp = eval([pthat_str,'_ramp']);
pthat_non = eval([pthat_str,'_non']);
errhat_str = 'SD';
errhat_ramp = eval([errhat_str,'_ramp']);
errhat_non = eval([errhat_str,'_non']);

%% decoding accuracy in ramps & non-ramps across models

% figure initialization
fig = figure(figopt,...
    'position',[100,50,440,420],...
    'name','ramps_decoding_accuracy');

% axes initialization
xxtick = unique((1:M)+[-1;0;1]*.05*M);
xxticklabel = num2cell(xxtick);
xxticklabel(~ismember(xxtick,1:M)) = {''};
xxticklabel(ismember(xxtick,1:M)) = model_labels;
axes(axesopt.default,...
    'plotboxaspectratio',[2.5,1,1],...
    'color','none',...
    'xlim',[1,M]+[-1,1]*.1*M,...
    'xtick',xxtick,...
    'xticklabel',xxticklabel,...
    'ylimspec','tight',...
    'clipping','off',...
    'layer','bottom');
xlabel('Parameter range');
ylabel('Error (ms)');

% offset between ramps and non-ramps
xoffsets = [-1,1] * .15;

% choice of accuracy function
accuracyfun = @(x,d) nanmean((x-t').^2,d);
accuracyfun = @(x,d) nanmean(abs(x-t'),d);

% choice of average and error functions
avgfun = @(x) nanmean(x);
errfun = @(x) [1,1] .* nanstd(x);
avgfun = @(x) nanmedian(x);
errfun = @(x) quantile(x,[.25,.75]) - nanmedian(x);

% preallocation
ramp_sims = nan(T,M);
non_sims = nan(T,M);

% iterate through models
for mm = 1 : M
    ramp_sims(:,mm) = accuracyfun(pthat_ramp(:,:,mm),2);
    non_sims(:,mm) = accuracyfun(pthat_non(:,:,mm),2);
    ramp_avg = avgfun(ramp_sims(:,mm));
    non_avg = avgfun(non_sims(:,mm));
    ramp_err = errfun(ramp_sims(:,mm));
    non_err = errfun(non_sims(:,mm));
    plot(mm+xoffsets,[ramp_avg,non_avg],...
        'color','k',...
        'linewidth',1.5);
    errorbar(mm+xoffsets(1),ramp_avg,...
        ramp_err(1),ramp_err(2),...
        'color','k',...
        'marker','o',...
        'markersize',7.5,...
        'markeredgecolor','k',...
        'markerfacecolor',ramp_clrs(1,:),...
        'linewidth',1.5,...
        'capsize',0);
    errorbar(mm+xoffsets(2),non_avg,...
        non_err(1),non_err(2),...
        'color','k',...
        'marker','o',...
        'markersize',7.5,...
        'markeredgecolor','k',...
        'markerfacecolor',ramp_clrs(2,:),...
        'linewidth',1.5,...
        'capsize',0);
end

% update axes
yymax = ceil(max(ylim)/10) * 10;
yylim = [0,yymax];
yytick = linspace(yylim(1),yylim(2),2);
yyticklabel = num2cell(yytick);
yyticklabel(~ismember(yytick,yylim)) = {''};
set(gca,...
    'ylim',yylim + [-1,1] * .05 * 2.5 * range(yylim),...
    'ytick',yytick,...
    'yticklabel',yyticklabel); % {'0',''});

% iterate through models
for mm = 1 : M
    xx = [-1,1] * .5 / 3 + mm;
    yy = [1,1] * max(yylim);
    plot(xx,yy,...
        'color','k',...
        'linewidth',1.5,...
        'handlevisibility','off');
    [~,pval] = kstest2(ramp_sims(:,mm),non_sims(:,mm));
    pval = kruskalwallis([ramp_sims(:,mm),non_sims(:,mm)],[],'off');
    if pval < .01
        test_str = '**';
    elseif pval < .05
        test_str = '*';
    else
        test_str = 'n.s.';
    end
    text(mean(xx),mean(yy)-.025/2.5*range(ylim),test_str,...
        'color','k',...
        'fontsize',16,...
        'horizontalalignment','center',...
        'verticalalignment','bottom');
end

% save figure
if want2save
    svg_file = fullfile(panel_path,[fig.Name,'.svg']);
    print(fig,svg_file,'-dsvg','-painters');
end

%% decoding precision in ramps & non-ramps across models

% figure initialization
fig = figure(figopt,...
    'position',[100,350,440,420],...
    'name','ramps_decoding_precision');

% axes initialization
xxtick = unique((1:M)+[-1;0;1]*.05*M);
xxticklabel = num2cell(xxtick);
xxticklabel(~ismember(xxtick,1:M)) = {''};
xxticklabel(ismember(xxtick,1:M)) = model_labels;
axes(axesopt.default,...
    'plotboxaspectratio',[2.5,1,1],...
    'color','none',...
    'xlim',[1,M]+[-1,1]*.1*M,...
    'xtick',xxtick,...
    'xticklabel',xxticklabel,...
    'ylimspec','tight',...
    'clipping','off',...
    'layer','bottom');
xlabel('Parameter range');
ylabel('SD of point estimates (ms)');

% offset between ramps and non-ramps
xoffsets = [-1,1] * .15;

% choice of precision function
precisionfun = @(x,d) 1 ./ nanvar(x,0,d);
precisionfun = @(x,d) nanstd(x,0,d);

% choice of average and error functions
avgfun = @(x) nanmean(x);
errfun = @(x) [1,1] .* nanstd(x);
avgfun = @(x) nanmedian(x);
errfun = @(x) quantile(x,[.25,.75]) - nanmedian(x);

% preallocation
ramp_sims = nan(T,M);
non_sims = nan(T,M);

% iterate through models
for mm = 1 : M
    ramp_sims(:,mm) = precisionfun(pthat_ramp(:,:,mm),2);
    non_sims(:,mm) = precisionfun(pthat_non(:,:,mm),2);
%     ramp_sims(:,mm) = nanmean(errhat_ramp(:,:,mm),1);
%     non_sims(:,mm) = nanmean(errhat_non(:,:,mm),1);
    ramp_avg = avgfun(ramp_sims(:,mm));
    non_avg = avgfun(non_sims(:,mm));
    ramp_err = errfun(ramp_sims(:,mm));
    non_err = errfun(non_sims(:,mm));
    plot(mm+xoffsets,[ramp_avg,non_avg],...
        'color','k',...
        'linewidth',1.5);
    errorbar(mm+xoffsets(1),ramp_avg,...
        ramp_err(1),ramp_err(2),...
        'color','k',...
        'marker','o',...
        'markersize',7.5,...
        'markeredgecolor','k',...
        'markerfacecolor',ramp_clrs(1,:),...
        'linewidth',1.5,...
        'capsize',0);
    errorbar(mm+xoffsets(2),non_avg,...
        non_err(1),non_err(2),...
        'color','k',...
        'marker','o',...
        'markersize',7.5,...
        'markeredgecolor','k',...
        'markerfacecolor',ramp_clrs(2,:),...
        'linewidth',1.5,...
        'capsize',0);
end

% update axes
yymax = ceil(max(ylim)/10) * 10;
yylim = [0,yymax];
yytick = linspace(yylim(1),yylim(2),2);
yyticklabel = num2cell(yytick);
yyticklabel(~ismember(yytick,yylim)) = {''};
set(gca,...
    'ylim',yylim + [-1,1] * .05 * 2.5 * range(yylim),...
    'ytick',yytick,...
    'yticklabel',yyticklabel);

% iterate through models
for mm = 1 : M
    xx = [-1,1] * .5 / 3 + mm;
    yy = [1,1] * max(yylim);
    plot(xx,yy,...
        'color','k',...
        'linewidth',1.5,...
        'handlevisibility','off');
    [~,pval] = kstest2(ramp_sims(:,mm),non_sims(:,mm));
    pval = kruskalwallis([ramp_sims(:,mm),non_sims(:,mm)],[],'off');
    if pval < .01
        test_str = '**';
    elseif pval < .05
        test_str = '*';
    else
        test_str = 'n.s.';
    end
    text(mean(xx),mean(yy)-.025/2.5*range(ylim),test_str,...
        'color','k',...
        'fontsize',16,...
        'horizontalalignment','center',...
        'verticalalignment','bottom');
end

% save figure
if want2save
    svg_file = fullfile(panel_path,[fig.Name,'.svg']);
    print(fig,svg_file,'-dsvg','-painters');
end

%% decoding precision in ramps & non-ramps across models

% figure initialization
fig = figure(figopt,...
    'position',[550,350,440,420],...
    'name','ramps_decoding_precision');

% axes initialization
xxtick = unique((1:M)+[-1;0;1]*.05*M);
xxticklabel = num2cell(xxtick);
xxticklabel(~ismember(xxtick,1:M)) = {''};
xxticklabel(ismember(xxtick,1:M)) = model_labels;
axes(axesopt.default,...
    'plotboxaspectratio',[2.5,1,1],...
    'color','none',...
    'xlim',[1,M]+[-1,1]*.1*M,...
    'xtick',xxtick,...
    'xticklabel',xxticklabel,...
    'ylimspec','tight',...
    'clipping','off',...
    'layer','bottom');
xlabel('Parameter range');
ylabel('SD (ms)');

% offset between ramps and non-ramps
xoffsets = [-1,1] * .15;

% choice of average and error functions
avgfun = @(x) nanmean(x);
errfun = @(x) [1,1] .* nanstd(x);
avgfun = @(x) nanmedian(x);
errfun = @(x) quantile(x,[.25,.75]) - nanmedian(x);

% preallocation
ramp_sims = nan(T,M);
non_sims = nan(T,M);

% iterate through models
for mm = 1 : M
    ramp_sims(:,mm) = nanmean(errhat_ramp(:,:,mm),2);
    non_sims(:,mm) = nanmean(errhat_non(:,:,mm),2);
    ramp_avg = avgfun(ramp_sims(:,mm));
    non_avg = avgfun(non_sims(:,mm));
    ramp_err = errfun(ramp_sims(:,mm));
    non_err = errfun(non_sims(:,mm));
    plot(mm+xoffsets,[ramp_avg,non_avg],...
        'color','k',...
        'linewidth',1.5);
    errorbar(mm+xoffsets(1),ramp_avg,...
        ramp_err(1),ramp_err(2),...
        'color','k',...
        'marker','o',...
        'markersize',7.5,...
        'markeredgecolor','k',...
        'markerfacecolor',ramp_clrs(1,:),...
        'linewidth',1.5,...
        'capsize',0);
    errorbar(mm+xoffsets(2),non_avg,...
        non_err(1),non_err(2),...
        'color','k',...
        'marker','o',...
        'markersize',7.5,...
        'markeredgecolor','k',...
        'markerfacecolor',ramp_clrs(2,:),...
        'linewidth',1.5,...
        'capsize',0);
end

% update axes
yymax = ceil(max(ylim)/10) * 10;
yylim = [0,yymax];
yytick = linspace(yylim(1),yylim(2),2);
yyticklabel = num2cell(yytick);
yyticklabel(~ismember(yytick,yylim)) = {''};
set(gca,...
    'ylim',yylim + [-1,1] * .05 * 2.5 * range(yylim),...
    'ytick',yytick,...
    'yticklabel',yyticklabel);

% iterate through models
for mm = 1 : M
    xx = [-1,1] * .5 / 3 + mm;
    yy = [1,1] * max(yylim);
    plot(xx,yy,...
        'color','k',...
        'linewidth',1.5,...
        'handlevisibility','off');
    [~,pval] = kstest2(ramp_sims(:,mm),non_sims(:,mm));
    pval = kruskalwallis([ramp_sims(:,mm),non_sims(:,mm)],[],'off');
    if pval < .01
        test_str = '**';
    elseif pval < .05
        test_str = '*';
    else
        test_str = 'n.s.';
    end
    text(mean(xx),mean(yy)-.025/2.5*range(ylim),test_str,...
        'color','k',...
        'fontsize',16,...
        'horizontalalignment','center',...
        'verticalalignment','bottom');
end

% save figure
if want2save
    svg_file = fullfile(panel_path,[fig.Name,'.svg']);
    print(fig,svg_file,'-dsvg','-painters');
end

%% compare decoding from ramps & non-ramps side by side

% iterate through models
for mm = 1 : M
    figure(figopt,...
        'name',sprintf('posterior_means (model %i)',mm),...
        'numbertitle','off',...
        'windowstyle','docked');
    n_rows = 1;
    n_cols = 2;
    sps = gobjects(n_rows,n_cols);
    for rr = 1 : n_rows
        for cc = 1 : n_cols
            sp_idx = cc + (rr - 1) * n_cols;
            sps(rr,cc) = subplot(n_rows,n_cols,sp_idx);
            xlabel(sps(rr,cc),'Time (ms)');
            ylabel(sps(rr,cc),'Decoded time (ms)');
        end
    end
    set(sps,...
        axesopt.default,...
        'xlim',[ti,tf],...
        'ylim',[ti,tf],...
        'xdir','normal',...
        'ydir','normal',...
        'nextplot','add',...
        'plotboxaspectratio',[1,1,1]);
    linkaxes(sps);
    
    % ramping posteriors
    title(sps(1),sprintf('Ramping neurons (%.0f%%)',nanmean(P_RAMP(:,mm))*100));
    errorbar(sps(1),...
        t,nanmean(pthat_ramp(:,:,mm),2),...
        nanmean(errhat_ramp(:,:,mm),2),...
        'color',ramp_clrs(1,:),...
        'linewidth',.1,...
        'capsize',0);
    plot(sps(1),t,nanmean(pthat_ramp(:,:,mm),2),...
        'color','w',...
        'linewidth',1.5);

    % non-ramping posteriors
    title(sps(2),sprintf('Non-ramping neurons (%.0f%%)',(1-nanmean(P_RAMP(:,mm)))*100));
    errorbar(sps(2),...
        t,nanmean(pthat_non(:,:,mm),2),...
        nanmean(errhat_non(:,:,mm),2),...
        'color',ramp_clrs(2,:),...
        'linewidth',.1,...
        'capsize',0);
    plot(sps(2),t,nanmean(pthat_non(:,:,mm),2),...
        'color','w',...
        'linewidth',1.5);

    % annotate model parameters
    text(sps(1),.05,.95,model_labels{mm},...
        'horizontalalignment','left',...
        'verticalalignment','top',...
        'units','normalized');
end

%% compare decoding from ramps & non-ramps (superimposed)

% figure initialization
fig = figure(figopt,...
    'name',sprintf('superimposed_posterior_means (model %i)',M));

% axes initialization
axes(axesopt.default,...
    'xlim',[ti,tf],...
    'ylim',[ti,tf],...
    'xtick',[ti,tf],...
    'ytick',[ti,tf],...
    'xdir','normal',...
    'ydir','normal',...
    'nextplot','add',...
    'clipping','off');
xlabel('Time (ms) X_i');
ylabel('Decoded time (ms) X_i');

% non-ramping posteriors
non_avg = nanmean(pthat_non(:,:,M),2);
non_err = [1,1] .* nanmean(errhat_non(:,:,M),2);
% non_err = errfun(pthat_non(:,:,M),2);
xpatch = [t,fliplr(t)];
ypatch = [non_avg-non_err(:,1);flipud(non_avg+non_err(:,2))];
patch(xpatch,ypatch,ramp_clrs(2,:),...
    'facealpha',1,...
    'edgecolor','none');

% ramping posteriors
ramp_avg = nanmean(pthat_ramp(:,:,M),2);
ramp_err = [1,1] .* nanmean(errhat_ramp(:,:,M),2);
% ramp_err = errfun(pthat_ramp(:,:,M),2);
xpatch = [t,fliplr(t)];
ypatch = [ramp_avg-ramp_err(:,1);flipud(ramp_avg+ramp_err(:,2))];
patch(xpatch,ypatch,ramp_clrs(1,:),...
    'facealpha',1,...
    'edgecolor','none');

% plot averages
plot(t,non_avg,...
    'color',([1,1,1]+ramp_clrs(2,:))/2,...
    'linewidth',1.5);
plot(t,ramp_avg,...
    'color',([1,1,1]+ramp_clrs(1,:))/2,...
    'linewidth',1.5);

% save figure
if want2save
    svg_file = fullfile(panel_path,[fig.Name,'.svg']);
    print(fig,svg_file,'-dsvg','-painters');
end

%% plot superimposed contrast-split posterior averages
fig = figure(...
    figopt,...
    'name','ramps_superimposed_posteriors',...
    'numbertitle','off');
axes(...
    axesopt.default,...
    'xlim',[ti,tf],...
    'ylim',[ti,tf]);
xlabel('Time since S_2 onset (ms)');
ylabel('Decoded time since S_2 onset (ms)');

% convert from tensor to rgb
P_tR_avg = cat(3,...
    squeeze(nanmean(P_TR_RAMP(:,:,:,M),3)),...
    squeeze(nanmean(P_TR_NON(:,:,:,M),3)));
P = tensor2rgb(permute(P_tR_avg,[2,1,3]),ramp_clrs);
imagesc([ti,tf],[ti,tf],P);

% zero lines
plot(xlim,[1,1]*0,':k');

% plot identity line
% plot([ti,tf],[ti,tf],':k');

% inset with pseudo colorbar
axes(...
    axesopt.default,...
    'position',[0.625,0.65,0.2583,0.2717],...
    'yaxislocation','right',...
    'xcolor','none',...
    'xlim',[0,1],...
    'ylim',[0,1],...
    'ytick',0,...
    'colormap',colorlerp(...
    [ramp_clrs(1,:);[1,1,1];ramp_clrs(end,:)],2^8));
ylabel('P(t|R)',...
    'verticalalignment','middle',...
    'rotation',-90);

% colorbar settings
clrbar_width = .05;

% iterate through contrasts
for ii = 1 : 2
    
    % patch pseudo-colorbar
    xpatch = (1 - clrbar_width * 2) + ...
        clrbar_width * ((ii - 1) + [0,1,1,0]);
    ypatch = [0,0,1,1];
    patch(xpatch,ypatch,ramp_clrs(ii,:),...
        'edgecolor','none',...
        'linewidth',1.5);
end

% save figure
if want2save
    svg_file = fullfile(panel_path,[fig.Name,'.svg']);
    print(fig,svg_file,'-dsvg','-painters');
end

%%
figure;
for mm = 1 : M
    subplot(M,1,mm);
    histogram(P_RAMP(:,mm),(0:.025:1.05)-.0125);
    xlim([0,1]);
end
figure(...
    'position',[1.0258e+03 41.8000 1.0224e+03 1.0288e+03]);
fr_edges = linspace(0,30,50);
for mm = 1 : M
    subplot(M,1,mm);
    set(gca,axesopt.default,...
        'plotboxaspectratio',[M,1,1]);
    xlabel('Firing rate (Hz)');
    ylabel('Count');
    mm_ramp_flags = SELECTED_RAMP_FLAGS(:,:,mm);
    mm_mean_fr = MEAN_FR(:,:,mm);
    histogram(mm_mean_fr(mm_ramp_flags),fr_edges,...
        'facecolor',ramp_clrs(1,:),...
        'linewidth',1.5);
    histogram(mm_mean_fr(~mm_ramp_flags),fr_edges,...
        'facecolor',ramp_clrs(2,:),...
        'linewidth',1.5);
    axis tight;
    yymax = max(ylim);
    plot([1,1]*mean(mm_mean_fr(mm_ramp_flags),[1,2]),[0,1]*yymax*1.05,...
        'color',ramp_clrs(1,:),...
        'linewidth',3);
    plot([1,1]*mean(mm_mean_fr(~mm_ramp_flags),[1,2]),[0,1]*yymax*1.05,...
        'color',ramp_clrs(2,:),...
        'linewidth',3);
end
return;

%% model specification

% figure initialization
fig = figure(figopt,...
    'position',[744,630,415,420],...
    'name','ramps_model_specification');

% model spec
mu_mdl = .5 * (tf - ti);
gamma_mdl = 5;
sigma_mdl = .15 * (tf - ti);
x_mdl = generativerate(t,gamma_mdl,mu_mdl,0,sigma_mdl);

% axes initialization
axes(axesopt.default,...
    'xcolor','k',...
    'xlim',[ti,tf]+[-1,1]*.05*(tf-ti),...
    'xtick',unique([ti,mu_mdl+[-1,0,1]*sigma_mdl,tf]),...
    'xticklabel',{num2str(ti),'$\mu-\sigma$','$\mu$','$\mu+\sigma$',num2str(tf)},...
    'ylim',[0,gamma_mdl]+[-1,1]*.15*range([0,gamma_mdl]),...
    'ytick',[0,gamma_mdl],...
    'yticklabel',{num2str(0),'$\gamma$'},...
    'ticklabelinterpreter','latex',...
    'clipping','off',...
    'plotboxaspectratio',[3,1,1]);
xlabel('Time (ms)');
ylabel('Firing rate (Hz)');

% model model illustration
plot(t,x_mdl,...
    'color','k',...
    'linewidth',1.5);

% annotate model spcification
text(.5,1.25,...
    ['$\rm{FR}=\gamma\cdot\mathcal{N}',...
    '(\nu\sim\mathcal{N}(\mu,\lambda),\sigma)$'],...
    'color','k',...
    'fontsize',12,...
    'interpreter','latex',...
    'horizontalalignment','center',...
    'units','normalized');
text(.5,1.05,...
    ['$\rm{FR}_{n,k}\propto\gamma_{n}\cdot\mathcal{N}',...
    '(\nu_{n,k}\sim\mathcal{N}(\mu_{n},\lambda_{n}),\sigma_{n})$'],...
    'color','k',...
    'fontsize',12,...
    'interpreter','latex',...
    'horizontalalignment','center',...
    'units','normalized');

% save figure
if want2save
    svg_file = fullfile(panel_path,[fig.Name,'.svg']);
    print(fig,svg_file,'-dsvg','-painters');
end

%% example neurons with opposite gammas & lambdas
K_eg = 10;

% preallocation
N_eg = 2;
X_eg = nan(T,N_eg,K_eg);
R_eg = nan(T,N_eg,K_eg);

% parameter choices
mus_eg = [...
    [1,1].*.75;...
    [1,1].*.25] * tf;
lambdas_eg = [...
    [0,0];...
    [0,1]*.25] * tf;
gammas_eg = [...
    [4,2];...
    [3,3]];
sigma_eg = .15 * (tf - ti);
n_eg = size(mus_eg,1);

% iterate through examples
for ee = 1 : n_eg
    
    % figure initialization
    fig = figure(figopt,...
        'position',[500+(ee-1)*300,350,200,275],...
        'name',sprintf('ramps_simulation_eg%i',ee));
    
    % axes settings
    yspacer = mean(gammas_eg(ee,:));
    axes(axesopt.default,...
        'xlim',[ti,tf],...
        'xtick',[ti,tf],...
        'ytick',[1,K_eg*yspacer],...
        'ytick',(1:K_eg)*yspacer,...
        'yticklabel',num2cell(1:K_eg),...
        'ylim',[1,K_eg+1]*yspacer+[-1,0]*.05*K_eg*yspacer,...
        'ylimspec','tight',...
        'ycolor','none',...
        'clipping','off',...
        'ticklength',axesopt.default.ticklength*2,...
        'plotboxaspectratio',[1,1,1]);
    xlabel('Time (ms)');
    ylabel('Trials');
    
    % iterate through neurons
    for nn = 1 : N_eg
        
        % iterate through trials
        for kk = 1 : K_eg
            X_eg(:,nn,kk) = generativerate(...
                t,gammas_eg(ee,nn),mus_eg(ee,nn),lambdas_eg(ee,nn),sigma_eg);
            [n,ts] = poissonprocess(X_eg(:,nn,kk),(tf-ti)/t_units);
            spk_times = ts * t_units + ti;
            spk_counts = histcounts(spk_times,...
                'binedges',[t,t(end)+1]);
            R_eg(:,nn,kk) = movsum(spk_counts,dt) / (dt/t_units);
        end
    end
    
    % compute cross-trial mean
    x_eg = nanmean(X_eg,3);

    % iterate through neurons
    for nn = 1 : N_eg
        
        % iterate through trials
        for kk = 1 : K_eg
            
            % plot single trial
            plot(t,X_eg(:,nn,kk)+kk*yspacer,...
                'color',ramp_clrs(nn,:),...
                'linewidth',1);
        end
    end
    
    % parameter annotation
    if ee == 1
        text(.5,1.3,'$\mu_1=\mu_2$',...
            'color','k',...
            'interpreter','latex',...
            'fontsize',12,...
            'horizontalalignment','center',...
            'units','normalized');
        text(.5,1.2,'$\gamma_1>\gamma_2$',...
            'color','k',...
            'interpreter','latex',...
            'fontsize',12,...
            'horizontalalignment','center',...
            'units','normalized');
        text(.5,1.1,'$\lambda_1=\lambda_2$',...
            'color','k',...
            'interpreter','latex',...
            'fontsize',12,...
            'horizontalalignment','center',...
            'units','normalized');
    else
        text(.5,1.3,'$\mu_1=\mu_2$',...
            'color','k',...
            'interpreter','latex',...
            'fontsize',12,...
            'horizontalalignment','center',...
            'units','normalized');
        text(.5,1.2,'$\gamma_1=\gamma_2$',...
            'color','k',...
            'interpreter','latex',...
            'fontsize',12,...
            'horizontalalignment','center',...
            'units','normalized');
        text(.5,1.1,'$\lambda_1>\lambda_2$',...
            'color','k',...
            'interpreter','latex',...
            'fontsize',12,...
            'horizontalalignment','center',...
            'units','normalized');
    end
    
    % save figure
    if want2save
        svg_file = fullfile(panel_path,[fig.Name,'.svg']);
        print(fig,svg_file,'-dsvg','-painters');
    end
end

%% firing rate function
function x = generativerate(time,gamma,mu,lambda,sigma)
    mu_sample = clamp(normrnd(mu,lambda),time(1),time(end));
    x_pdf = normpdf(time,mu_sample,sigma);
    x = gamma * x_pdf ./ max(x_pdf);
end