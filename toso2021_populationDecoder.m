%% initialization
if ~exist('data','var')
    toso2021_wrapper;
end

%% run settings
n_runs = 1;

%% bootstrap settings
n_boots = 0; % 1e3;

%% GLM settings
distro = 'normal';
glm_wins = t_set(t1_mode_idx);
% glm_wins = t_set(1:end);
n_glm = numel(glm_wins);

%% preallocation
spkcounts = struct(); % MISSING THE NEURON DIMENSION!!! N x K (rtials)
performance = struct();

%% iterate through runs
for rr = 1 : n_runs
    if n_runs > 1
        toso2021_simulateSpikes;
        spike_data_field = 'FakeFR';
    else
        spike_data_field = 'FR';
    end
    
    %% iterate through spike integration windows
    for gg = 1 : n_glm
        glm_win = glm_wins(gg);
        glm_str = sprintf('t%i',glm_win);
        
        %% ROI settings
        
        % initialization
        glm_roi = struct();
        glm_roi_lbl = struct();
        
        % roi definitions
        %         glm_roi.aroundInitMov = [-glm_win,0] - 316;
        glm_roi.preInit = [-glm_win,0];
        glm_roi.postInit = [0,glm_win];
        glm_roi.preS1Onset = [-glm_win,0];
        glm_roi.postS1Onset = [0,glm_win];
        glm_roi.preS1Offset = [-glm_win,0];
        glm_roi.postS1Offset = [0,glm_win];
        glm_roi.preS2Onset = [-glm_win,0];
        glm_roi.postS2Onset = [0,glm_win];
        glm_roi.preS2Offset = [-glm_win,0];
        glm_roi.postS2Offset = [0,glm_win];
        glm_roi.preGoCue = [-glm_win,0];
        glm_roi.postGoCue = [0,glm_win];
        glm_roi.aroundReaction = glm_roi.postGoCue + glm_win;
        glm_roi.aroundChoice = glm_roi.postGoCue + glm_win * 2;
        
        % roi labels
        %         glm_roi_lbl.aroundInitMov = 'Initiation movement';
        glm_roi_lbl.preInit = 'Pre-initiation';
        glm_roi_lbl.postInit = 'Post-initiation';
        glm_roi_lbl.preS1Onset = 'Pre-S1 onset';
        glm_roi_lbl.postS1Onset = 'Post-S1 onset';
        glm_roi_lbl.preS1Offset = 'Pre-S1 offset';
        glm_roi_lbl.postS1Offset = 'Post-S1 offset';
        glm_roi_lbl.preS2Onset = 'Pre-S2 onset';
        glm_roi_lbl.postS2Onset = 'Post-S2 onset';
        glm_roi_lbl.preS2Offset = 'Pre-S2 offset';
        glm_roi_lbl.postS2Offset = 'Post-S2 offset';
        glm_roi_lbl.preGoCue = 'Pre-go cue';
        glm_roi_lbl.postGoCue = 'Post-go cue';
        glm_roi_lbl.aroundReaction = '~Reaction';
        glm_roi_lbl.aroundChoice = '~Choice';
        
        % adjust if simulating
        if n_runs > 1
            all_fields = fieldnames(glm_roi);
            fields2rm = ~ismember(all_fields,...
                {'postS1Onset','preS1Offset','postS2Onset','preS2Offset'});
            glm_roi = rmfield(glm_roi,all_fields(fields2rm));
            glm_roi_lbl = rmfield(glm_roi_lbl,all_fields(fields2rm));
        end
        
        % epoch parsing
        epochs = fieldnames(glm_roi);
        n_epochs = numel(epochs);
        
        %% neuron selection
        
        % selected for being good examples of i2-modulation
        if strcmpi(task_str,'duration')
            neurons2use = [...
                21,24,35,38,62,65,68,72,100,130,205,206,215,224,...
                234,241,356,381,391,393,397,402,406,428,441,448,...
                459,461,462,470,473,493,526,544,553,555,566];
            %     neurons2use = [...
            %         38,72,205,215,224,391,393,397,402,448,459,462,470,526,566];
        elseif strcmpi(task_str,'intensity')
            neurons2use = [...
                19,22,30,61,66,70,100,111,112,115,...
                166,238,243,260,344,408,410];
        end
        neurons2use = flagged_neurons;
        % neurons2use = neuron_idcs;
        n_neurons2use = numel(neurons2use);
        
        %% construct response
        
        % iterate through neurons
        for nn = 1 : n_neurons2use
            progressreport(nn,n_neurons2use,'fetching spike counts');
            neuron_flags = data.NeuronNumb == neurons2use(nn);
            
            % flag trials for the current condition
            trial_flags = ...
                valid_flags & ...
                neuron_flags;
            if sum(trial_flags) == 0
                continue;
            end
            
            % fetch spike counts & compute spike rates
            spike_counts = data.(spike_data_field)(trial_flags,:)';
            n_trials = sum(trial_flags);
            
            % around approach spike rates
            if isfield(glm_roi,'aroundInitMov')
                alignment_onset = ...
                    repmat(pre_init_padding,n_trials,1);
                alignment_flags = ...
                    padded_time >= alignment_onset + glm_roi.aroundInitMov(1) & ...
                    padded_time < alignment_onset + glm_roi.aroundInitMov(2);
                chunk_flags = alignment_flags;
                spkcounts_aroundInitMov = spike_counts;
                spkcounts_aroundInitMov(~alignment_flags') = nan;
                spkcounts_aroundInitMov = ...
                    reshape(spkcounts_aroundInitMov(chunk_flags'),[glm_win,n_trials])';
                spkcounts.aroundInitMov(gg,trial_flags) = nansum(spkcounts_aroundInitMov,2);
            end
            
            % pre initiation spike rates
            if isfield(glm_roi,'preInit')
                alignment_onset = ...
                    repmat(pre_init_padding,n_trials,1);
                alignment_flags = ...
                    padded_time >= alignment_onset + glm_roi.preInit(1) & ...
                    padded_time < alignment_onset + glm_roi.preInit(2);
                chunk_flags = alignment_flags;
                spkcounts_preInit = spike_counts;
                spkcounts_preInit(~alignment_flags') = nan;
                spkcounts_preInit = ...
                    reshape(spkcounts_preInit(chunk_flags'),[glm_win,n_trials])';
                spkcounts.preInit(gg,trial_flags) = nansum(spkcounts_preInit,2);
            end
            
            % post initiation spike rates
            if isfield(glm_roi,'postInit')
                alignment_onset = ...
                    repmat(pre_init_padding,n_trials,1);
                alignment_flags = ...
                    padded_time >= alignment_onset + glm_roi.postInit(1) & ...
                    padded_time < alignment_onset + glm_roi.postInit(2);
                chunk_flags = alignment_flags;
                spkcounts_postInit = spike_counts;
                spkcounts_postInit(~alignment_flags') = nan;
                spkcounts_postInit = ...
                    reshape(spkcounts_postInit(chunk_flags'),[glm_win,n_trials])';
                spkcounts.postInit(gg,trial_flags) = nansum(spkcounts_postInit,2);
            end
            
            % pre-S1 onset spike rates
            if isfield(glm_roi,'preS1Onset')
                alignment_onset = ...
                    pre_init_padding + ...
                    pre_s1_delay(trial_flags);
                alignment_flags = ...
                    padded_time >= alignment_onset + glm_roi.preS1Onset(1) & ...
                    padded_time < alignment_onset + glm_roi.preS1Onset(2);
                chunk_flags = alignment_flags;
                spkcounts_preS1Onset = spike_counts;
                spkcounts_preS1Onset(~alignment_flags') = nan;
                spkcounts_preS1Onset = ...
                    reshape(spkcounts_preS1Onset(chunk_flags'),[glm_win,n_trials])';
                spkcounts.preS1Onset(gg,trial_flags) = nansum(spkcounts_preS1Onset,2);
            end
            
            % post-S1 onset spike rates
            alignment_onset = ...
                pre_init_padding + ...
                pre_s1_delay(trial_flags);
            alignment_flags = ...
                padded_time >= alignment_onset + glm_roi.postS1Onset(1) & ...
                padded_time < alignment_onset + t1(trial_flags);
            chunk_flags = ...
                padded_time >= alignment_onset + glm_roi.postS1Onset(1) & ...
                padded_time < alignment_onset + glm_roi.postS1Onset(2);
            spkcounts_postS1Onset = spike_counts;
            spkcounts_postS1Onset(~alignment_flags') = nan;
            spkcounts_postS1Onset = ...
                reshape(spkcounts_postS1Onset(chunk_flags'),[glm_win,n_trials])';
            
            % pre-S1 offset spike rates
            alignment_onset = ...
                pre_init_padding + ...
                pre_s1_delay(trial_flags) + ...
                t1(trial_flags);
            alignment_flags = ...
                padded_time >= alignment_onset - t1(trial_flags) & ...
                padded_time < alignment_onset + glm_roi.preS1Offset(2);
            chunk_flags = ...
                padded_time >= alignment_onset + glm_roi.preS1Offset(1) & ...
                padded_time < alignment_onset + glm_roi.preS1Offset(2);
            spkcounts_preS1Offset = spike_counts;
            spkcounts_preS1Offset(~alignment_flags') = nan;
            spkcounts_preS1Offset = ...
                reshape(spkcounts_preS1Offset(chunk_flags'),[glm_win,n_trials])';
            
            % post-S1 offset spike rates
            if isfield(glm_roi,'postS1Offset')
                alignment_onset = ...
                    pre_init_padding + ...
                    pre_s1_delay(trial_flags) + ...
                    t1(trial_flags);
                alignment_flags = ...
                    padded_time >= alignment_onset + glm_roi.postS1Offset(1) & ...
                    padded_time < alignment_onset + glm_roi.postS1Offset(2);
                chunk_flags = alignment_flags;
                spkcounts_postS1Offset = spike_counts;
                spkcounts_postS1Offset(~alignment_flags') = nan;
                spkcounts_postS1Offset = ...
                    reshape(spkcounts_postS1Offset(chunk_flags'),[glm_win,n_trials])';
                spkcounts.postS1Offset(gg,trial_flags) = nansum(spkcounts_postS1Offset,2);
            end
            
            % pre-S2 onset spike rates
            if isfield(glm_roi,'preS2Onset')
                alignment_onset = ...
                    pre_init_padding + ...
                    pre_s1_delay(trial_flags) + ...
                    t1(trial_flags) + ...
                    isi;
                alignment_flags = ...
                    padded_time >= alignment_onset + glm_roi.preS2Onset(1) & ...
                    padded_time < alignment_onset + glm_roi.preS2Onset(2);
                chunk_flags = alignment_flags;
                spkcounts_preS2Onset = spike_counts;
                spkcounts_preS2Onset(~alignment_flags') = nan;
                spkcounts_preS2Onset = ...
                    reshape(spkcounts_preS2Onset(chunk_flags'),[glm_win,n_trials])';
                spkcounts.preS2Onset(gg,trial_flags) = nansum(spkcounts_preS2Onset,2);
            end
            
            % post-S2 onset spike rates
            alignment_onset = ...
                pre_init_padding + ...
                pre_s1_delay(trial_flags) + ...
                t1(trial_flags) + ...
                isi;
            alignment_flags = ...
                padded_time >= alignment_onset + glm_roi.postS2Onset(1) & ...
                padded_time < alignment_onset + t2(trial_flags);
            chunk_flags = ...
                padded_time >= alignment_onset + glm_roi.postS2Onset(1) & ...
                padded_time < alignment_onset + glm_roi.postS2Onset(2);
            spkcounts_postS2Onset = spike_counts;
            spkcounts_postS2Onset(~alignment_flags') = nan;
            spkcounts_postS2Onset = ...
                reshape(spkcounts_postS2Onset(chunk_flags'),[glm_win,n_trials])';
            
            % pre-S2 offset spike rates
            alignment_onset = ...
                pre_init_padding + ...
                pre_s1_delay(trial_flags) + ...
                t1(trial_flags) + ...
                isi + ...
                t2(trial_flags);
            alignment_flags = ...
                padded_time >= alignment_onset - t2(trial_flags) & ...
                padded_time < alignment_onset + glm_roi.preS2Offset(2);
            chunk_flags = ...
                padded_time >= alignment_onset + glm_roi.preS2Offset(1) & ...
                padded_time < alignment_onset + glm_roi.preS2Offset(2);
            spkcounts_preS2Offset = spike_counts;
            spkcounts_preS2Offset(~alignment_flags') = nan;
            spkcounts_preS2Offset = ...
                reshape(spkcounts_preS2Offset(chunk_flags'),[glm_win,n_trials])';
            
            % post-S2 offset spike rates
            if isfield(glm_roi,'postS2Offset')
                alignment_onset = ...
                    pre_init_padding + ...
                    pre_s1_delay(trial_flags) + ...
                    t1(trial_flags) + ...
                    isi + ...
                    t2(trial_flags);
                alignment_flags = ...
                    padded_time >= alignment_onset + glm_roi.postS2Offset(1) & ...
                    padded_time < alignment_onset + glm_roi.postS2Offset(2);
                chunk_flags = alignment_flags;
                spkcounts_postS2Offset = spike_counts;
                spkcounts_postS2Offset(~alignment_flags') = nan;
                spkcounts_postS2Offset = ...
                    reshape(spkcounts_postS2Offset(chunk_flags'),[glm_win,n_trials])';
                spkcounts.postS2Offset(gg,trial_flags) = nansum(spkcounts_postS2Offset,2);
            end
            
            % pre-go spike rates
            if isfield(glm_roi,'preGoCue')
                alignment_onset = ...
                    pre_init_padding + ...
                    pre_s1_delay(trial_flags) + ...
                    t1(trial_flags) + ...
                    isi + ...
                    t2(trial_flags) + ...
                    post_s2_delay;
                alignment_flags = ...
                    padded_time >= alignment_onset + glm_roi.preGoCue(1) & ...
                    padded_time < alignment_onset + glm_roi.preGoCue(2);
                chunk_flags = alignment_flags;
                spkcounts_preGoCue = spike_counts;
                spkcounts_preGoCue(~alignment_flags') = nan;
                spkcounts_preGoCue = ...
                    reshape(spkcounts_preGoCue(chunk_flags'),[glm_win,n_trials])';
                spkcounts.preGoCue(gg,trial_flags) = nansum(spkcounts_preGoCue,2);
            end
            
            % post-go spike rates
            if isfield(glm_roi,'postGoCue')
                alignment_onset = ...
                    pre_init_padding + ...
                    pre_s1_delay(trial_flags) + ...
                    t1(trial_flags) + ...
                    isi + ...
                    t2(trial_flags) + ...
                    post_s2_delay;
                alignment_flags = ...
                    padded_time >= alignment_onset + glm_roi.postGoCue(1) & ...
                    padded_time < alignment_onset + glm_roi.postGoCue(2);
                chunk_flags = alignment_flags;
                spkcounts_postGoCue = spike_counts;
                spkcounts_postGoCue(~alignment_flags') = nan;
                spkcounts_postGoCue = ...
                    reshape(spkcounts_postGoCue(chunk_flags'),[glm_win,n_trials])';
                spkcounts.postGoCue(gg,trial_flags) = nansum(spkcounts_postGoCue,2);
            end
            
            % around choice spike rates
            if isfield(glm_roi,'aroundReaction')
                alignment_onset = ...
                    pre_init_padding + ...
                    pre_s1_delay(trial_flags) + ...
                    t1(trial_flags) + ...
                    isi + ...
                    t2(trial_flags) + ...
                    post_s2_delay;
                alignment_flags = ...
                    padded_time >= alignment_onset + glm_roi.aroundReaction(1) & ...
                    padded_time < alignment_onset + glm_roi.aroundReaction(2);
                chunk_flags = alignment_flags;
                spkcounts_aroundReaction = spike_counts;
                spkcounts_aroundReaction(~alignment_flags') = nan;
                spkcounts_aroundReaction = ...
                    reshape(spkcounts_aroundReaction(chunk_flags'),[glm_win,n_trials])';
                spkcounts.aroundReaction(gg,trial_flags) = nansum(spkcounts_aroundReaction,2);
            end
            
            % around choice spike rates
            if isfield(glm_roi,'aroundChoice')
                alignment_onset = ...
                    pre_init_padding + ...
                    pre_s1_delay(trial_flags) + ...
                    t1(trial_flags) + ...
                    isi + ...
                    t2(trial_flags) + ...
                    post_s2_delay;
                alignment_flags = ...
                    padded_time >= alignment_onset + glm_roi.aroundChoice(1) & ...
                    padded_time < alignment_onset + glm_roi.aroundChoice(2);
                chunk_flags = alignment_flags;
                spkcounts_aroundChoice = spike_counts;
                spkcounts_aroundChoice(~alignment_flags') = nan;
                spkcounts_aroundChoice = ...
                    reshape(spkcounts_aroundChoice(chunk_flags'),[glm_win,n_trials])';
                spkcounts.aroundChoice(gg,trial_flags) = nansum(spkcounts_aroundChoice,2);
            end
            
            % store average spike rates
            spkcounts.postS1Onset(gg,trial_flags) = nansum(spkcounts_postS1Onset,2);
            spkcounts.preS1Offset(gg,trial_flags) = nansum(spkcounts_preS1Offset,2);
            spkcounts.postS2Onset(gg,trial_flags) = nansum(spkcounts_postS2Onset,2);
            spkcounts.preS2Offset(gg,trial_flags) = nansum(spkcounts_preS2Offset,2);
        end
        
        %% LDA-based population decoder (1 vs. all)
        
        % response selection
        response_table = table(t1,t2,i1,i2);
        response_names = response_table.Properties.VariableNames;
        n_responses = numel(response_table);
        
        % iterate through epochs
        for ee = 1 : n_epochs
            epoch = epochs{ee};

            % duration selection
            t1_flags = t1 >= glm_win * ...
                ismember(epoch,{'postS1Onset','preS1Offset'});
            t2_flags = t2 >= glm_win * ...
                ismember(epoch,{'postS2Onset','preS2Offset'});
            
            % trial selection
            trial_flags = ...
                valid_flags & ...
                t1_flags & ...
                t2_flags;
            n_flagged_trials = sum(trial_flags);
            if n_flagged_trials <= 1
                continue;
            end
            flagged_trial_idcs = find(trial_flags);
            
            % hyperparameter optimization options
%             hyperopt = struct(...
%                 'verbose',1,...
%                 'cvpartition',cvpartition(n_flagged_trials,'leaveout'));
            
            % iterate through responses
            for ii = 1 : n_responses
                response_str = response_names{ii}; 
                response = response_table.(response_str);
                response_set = eval([response_str,'_set']);
                
                % iterate through response values
                for jj = 1 : 1
                    
                    % linear discriminant analysis (w/ leave-one out x-val)
%                     X = spkcounts.(epoch)(gg,trial_flags)';
%                     y = response(trial_flags) == response_set(jj);
%                     lda_mdl = fitcdiscr(X,y,...
%                         'discrimtype','linear',...
%                         ...'leaveout','on',...
%                         'optimizehyperparameters','auto',...
%                         'hyperparameteroptimizationoptions',hyperopt);
%                     
%                     % caching
%                     performance.(epoch)(gg,trial_flags) = 1; % !!!!!!!!!!!!
                    
                    % eventually it'd be nice to drop neurons and keep tabs
                    % on performance, what's the kosher way of doing this?
                    % do a bunch of runs changing drop order?
                    
                    % iterate through trials
                    for tt = 1 : n_flagged_trials
                        progressreport(tt,n_flagged_trials,...
                            sprintf('cross-validating (%s)',response_str));
                        
                        % handle leave-one-out cross-validation
                        train_flags = flagged_trial_idcs ~= flagged_trial_idcs(tt);

                        % linear discriminant analysis
                        X = spkcounts.(epoch)(gg,train_flags)';
                        y = response(train_flags) == response_set(jj);
                        lda_mdl = fitcdiscr(X,y,...
                            'discrimtype','linear');
                        
                        % caching
                        X = spkcounts.(epoch)(gg,~train_flags)';
                        performance.(epoch)(gg,~train_flags) = ...
                            lda_mdl.predict(X);
                        
                        a=1
                    end
                end
            end
        end
        
        %% plot decoding performance
        
        % bar width settings
        epoch_span = 1 / 3;
        barwidth = epoch_span / n_responses;
        
        % figure initialization
        fig = figure(figopt,...
            'name',sprintf('GLM_significance_crossEpochs_%s_%i_%s_highlight',...
            distro,glm_win,strrep([response_labels{:}],'_','')),...
            'color',[1,1,1]*1);
        
        % axes initialization
        yymax = .25;
        yylim = [-1,1]*yymax+[-1,1]*.05*yymax*2;
        yytick = -yymax : .05 : yymax;
        yyticklabel = num2cell(abs(round(yytick,2)));
        yyticklabel(~ismember(yytick,[0,[-1,1]*yymax,[-1,1]*.05])) = {''};
        axes(axesopt.default,...
            'plotboxaspectratio',[1,1,1],...
            'color','none',...
            'xlim',[1,n_epochs]+[-1,1]*.05*n_epochs,...
            'xtick',1:n_epochs,...
            'xticklabel',num2cell(1:n_epochs),...struct2cell(glm_roi_lbl),...
            'xticklabelrotation',90,...
            'ylim',yylim,...
            'ytick',yytick,...
            'yticklabel',yyticklabel,...
            'xcolor','k',...
            'clipping','off',...
            'layer','bottom');
        xlabel('Task epoch');
        ylabel({'P(significant regression coefficients)',...
            '\downarrow-modulated                   \uparrow-modulated'},...
            'verticalalignment','bottom');
        
        % significance settings
        alphas = [.05,.01];
        n_alphas = numel(alphas);
        pval_corr = 3;
        
        % reference lines
        plot(xlim,[1,1]*0,'-k',...
            'linewidth',1.5);
 
        % pseudo-legend (stimulus epochs)
        s1epoch_idcs = ...
            [find(ismember(epochs,'postS1Onset')),...
            find(ismember(epochs,'preS1Offset'))];
        plot(s1epoch_idcs+[-1,1]*.5,[1,1]*yymax,...
            'linestyle','-',...
            'linewidth',3,...
            'color',stim_clrs(1,:));
        text(mean(s1epoch_idcs),yymax*1.025,'S1',...
            'color',stim_clrs(1,:),...
            'fontsize',12,...
            'horizontalalignment','center',...
            'verticalalignment','bottom');
        s2epoch_idcs = ...
            [find(ismember(epochs,'postS2Onset')),...
            find(ismember(epochs,'preS2Offset'))];
        plot(s2epoch_idcs+[-1,1]*.5,[1,1]*yymax,...
            'linestyle','-',...
            'linewidth',3,...
            'color',stim_clrs(2,:));
        text(mean(s2epoch_idcs),yymax*1.025,'S2',...
            'color',stim_clrs(2,:),...
            'fontsize',12,...
            'horizontalalignment','center',...
            'verticalalignment','bottom');
        
        % graphical object preallocation
        h = gobjects((n_coefficients-2)*n_epochs*2*n_alphas,1);
        h_idx = 1;
        
        % iterate through epochs
        for ee = 1 : n_epochs
            epoch = epochs{ee};
            
            % epoch delimeter
            p = plot([1,1]*ee+1/2,[-1.1,1]*yymax,...
                'color','k',...
                'linestyle','--');
            uistack(p,'bottom');
            
            % pseudo x-tick label
            text(ee,-yymax*1.15,glm_roi_lbl.(epoch),...
                'horizontalalignment','center',...
                'rotation',90,...
                'color','k',...
                'fontsize',10);
            
            % compute horizontal offsets
            x_offsets = ee + (0 : n_responses - 1) * barwidth + ...
                barwidth / 2 - epoch_span / 2;
            
            % iterate through alphas
            for aa = 1 : n_alphas
                
                % preallocation
                P = nan(n_responses,2);
                
                % iterate through coefficients
                for bb = 1 : n_responses
                    coeff_lbl = response_labels{bb};
                    coeff_idx = find(ismember(mdl.CoefficientNames,coeff_lbl));
                    coeff_lbl = strrep(coeff_lbl,'#','');
                    coeff_str = strrep(lower(coeff_lbl),'_','');
                    coeff_clrs = eval([coeff_str,'_clrs']);
                    x = x_offsets(bb);
                    
                    % significance flags
                    significant_flags = pvals_corrected.(epoch)(:,coeff_idx) <= alphas(aa);
         
                    % iterate through signs
                    signs = [-1,1];
                    for ss = 1 : 2
                        sign_flags = sign(betas.(epoch)(:,coeff_idx)) == signs(ss);
                        n = sum(significant_flags & sign_flags);
                        p = n / n_neurons2use;
                        
                        % store proportion for later use
                        fractions.(glm_str).(epoch).(coeff_lbl)(rr,aa,ss) = p;
                        
                        if signs(ss) == -1
                            facecolor = coeff_clrs(1,:);
                        else
                            facecolor = coeff_clrs(end,:);
                        end
                        if ~coeffs2highlight_flags(bb) % p < alphas(aa)
                            facecolor = [1,1,1] * .75;
                            edgecolor = 'none';
                        else
                            edgecolor = 'k';
                        end
                        if alphas(aa) == max(alphas)
                            n_fadedcolors = 5;
                            clrs = colorlerp([facecolor;[1,1,1]],n_fadedcolors);
                            facecolor = clrs(end-1,:);
                        end
                        xpatch = x + [-1,1,1,-1] / 2 * barwidth * 1;
                        ypatch = p * signs(ss) .* [0,0,1,1];
                        patch(xpatch,ypatch,'k',...
                            'edgecolor','none',...
                            'facecolor',facecolor,...
                            'facealpha',1,...
                            'linewidth',1.5);
                        if false % p >= alphas(aa)
                            h(h_idx) = patch(xpatch,ypatch,'k',...
                                'edgecolor','k',...
                                'facecolor','none',...
                                'linewidth',1.5);
                            h_idx = h_idx + 1;
                        end
                        
                        P(bb,ss) = p;
                        if alphas(aa) == max(alphas) && bb == n_responses
                            xstairs = ...
                                [x_offsets(coeffs2highlight_idcs(1)),...
                                x_offsets(coeffs2highlight_idcs),...
                                x_offsets(coeffs2highlight_idcs(end)),...
                                x_offsets(coeffs2highlight_idcs(end))+barwidth]-barwidth/2;
                            ystairs = [0;...
                                P(coeffs2highlight_idcs,ss);...
                                P(coeffs2highlight_idcs(end),ss)*[1;0]] * signs(ss);
                            h(h_idx) = stairs(xstairs,ystairs,...
                                'color','k',...
                                'linewidth',1.5);
                            h_idx = h_idx + 1;
                        end
                    end
                    
                    % pseudo-legend (significance)
                    if ee == 1 && bb == 1
                        aspectratio = pbaspect;
                        xpatch = n_epochs + [-1,1,1,-1] * .25 / (1 + (alphas(aa) == min(alphas))) - ...
                            .125 * (alphas(aa) == min(alphas));
                        ypatch = yymax + [0,0,1,1] * barwidth * ...
                            range(ylim) / range(xlim) * aspectratio(1) / aspectratio(2);
                        if alphas(aa) == min(alphas)
                            clr = [0,0,0];
                        else
                            clrs = colorlerp([[0,0,0];[1,1,1]],n_fadedcolors);
                            clr = clrs(end-1,:);
                        end
                        patch(xpatch,ypatch,clr,...
                            'facealpha',1,...
                            'linewidth',1.5);
                        if alphas(aa) == max(alphas)
                            text(mean(xpatch),mean(ypatch)+.01,'\alpha',...
                                'color','k',...
                                'fontsize',12,...
                                'fontweight','normal',...
                                'horizontalalignment','center',...
                                'verticalalignment','bottom');
                        end
                        if alphas(aa) == max(alphas)
                            horzalignment = 'left';
                            xalpha = max(xpatch) + .06;
                        else
                            horzalignment = 'right';
                            xalpha = min(xpatch) - .06;
                        end
                        text(xalpha,mean(ypatch)+.0025,sprintf('%.2f',alphas(aa)),...
                            'color','k',...
                            'fontsize',8,...
                            'horizontalalignment',horzalignment,...
                            'verticalalignment','middle');
                    end
                end
            end
        end
        
        % ui resorting
        uistack(h(isgraphics(h)),'top');
        
        % save figure
        if want2save
            svg_file = fullfile(panel_path,[fig.Name,'.svg']);
            print(fig,svg_file,'-dsvg','-painters');
        end
        
        %% highlight coefficients of interest
        
        % coefficient selection
        coeffsets2plot = {...
            'T_1','T_2';...
            'I_1','I_2',...
            };
        [n_coeffsets,n_coeffsperset] = size(coeffsets2plot);
        setyymax = .3 ./ [1,2];
        setlabels = {'Duration','Intensity'};
        
        % iterate through coeff set
        for ss = 1 : n_coeffsets
            
            % figure initialization
            fig = figure(figopt,...
                'name',sprintf('GLM_significance_%s_%i_%s',...
                distro,glm_win,lower(setlabels{ss})),...
                'position',[540,630,765,420],...
                'color',[1,1,1]*1);
            
            % axes initialization
            yymax = setyymax(ss);
            yylim = [0,1]*yymax+[-1,1]*.05*yymax;
            yytick = unique([0,[0,1]*yymax,[0,1]*.05,[0,1]*.01]);
            yyticklabel = num2cell(abs(round(yytick,2)));
            yyticklabel(~ismember(yytick,[0,[0,1]*yymax])) = {''};
            axes(axesopt.default,...
                'plotboxaspectratio',[3.5,1,1],...
                'color','none',...
                'ticklength',axesopt.default.ticklength*.58,...
                'xlim',[1,n_epochs]+[-1,1]*.75,...
                'xtick',1:n_epochs,...
                'xticklabel',struct2cell(glm_roi_lbl),...
                'xticklabelrotation',45,...
                'ylim',yylim,...
                'ytick',yytick,...
                'yticklabel',yyticklabel,...
                'clipping','off',...
                'layer','bottom');
            %             title(sprintf('%s',setlabels{ss}));
            ylabel(sprintf('P(significant %s coefficients)','regression'));
            
            % pseudo-legend (stimulus epochs)
            s1epoch_idcs = ...
                [find(ismember(epochs,'postS1Onset')),...
                find(ismember(epochs,'preS1Offset'))];
            plot(s1epoch_idcs,[1,1]*yymax,...
                'linestyle','-',...
                'linewidth',3,...
                'color',stim_clrs(1,:));
            text(mean(s1epoch_idcs),yymax*1.025,...
                sprintf('%s presentation',strrep(coeffsets2plot{ss,1},'_','')),...
                'color',stim_clrs(1,:),...
                'fontsize',12,...
                'horizontalalignment','center',...
                'verticalalignment','bottom');
            s2epoch_idcs = ...
                [find(ismember(epochs,'postS2Onset')),...
                find(ismember(epochs,'preS2Offset'))];
            plot(s2epoch_idcs,[1,1]*yymax,...
                'linestyle','-',...
                'linewidth',3,...
                'color',stim_clrs(2,:));
            text(mean(s2epoch_idcs),yymax*1.025,...
                sprintf('%s presentation',strrep(coeffsets2plot{ss,2},'_','')),...
                'color',stim_clrs(2,:),...
                'fontsize',12,...
                'horizontalalignment','center',...
                'verticalalignment','bottom');
            
            % reference lines
            %             plot(xlim,[1,1]*min(alphas),':k');
            %             plot(xlim,[1,1]*max(alphas),':k');
            
            % iterate through coefficients
            for bb = 1 : n_coeffsperset
                coeff_lbl = coeffsets2plot{ss,bb};
                coeff_idx = find(ismember(mdl.CoefficientNames,coeff_lbl));
                coeff_lbl = strrep(coeff_lbl,'#','');
                coeff_str = strrep(lower(coeff_lbl),'_','');
                coeff_clrs = eval([coeff_str,'_clrs']);
                
                %             % figure initialization
                %             fig = figure(figopt,...
                %                 'name',sprintf('GLM_significance_%s_%i_%s',distro,glm_win,coeff_lbl),...
                %                 'color',[1,1,1]*1);
                %
                %             % axes initialization
                %             yymax = .3;
                %             yylim = [0,1]*yymax+[-1,1]*.05*yymax;
                %             yytick = unique([0,[0,1]*yymax,[0,1]*.05,[0,1]*.01]);
                %             yyticklabel = num2cell(abs(round(yytick,2)));
                %             yyticklabel(~ismember(yytick,[0,[0,1]*yymax])) = {''};
                %             axes(axesopt.default,...
                %                 'plotboxaspectratio',[3,1,1],...
                %                 'color','none',...
                %                 'ticklength',axesopt.default.ticklength*.58,...
                %                 'xlim',[1,n_epochs]+[-1,1]*.75,...
                %                 'xtick',1:n_epochs,...
                %                 'xticklabel',struct2cell(glm_roi_lbl),...
                %                 'xticklabelrotation',45,...
                %                 'ylim',yylim,...
                %                 'ytick',yytick,...
                %                 'yticklabel',yyticklabel,...
                %                 'clipping','off',...
                %                 'layer','bottom');
                %             title(sprintf('\\beta_{%s}',capitalize(coeff_str)));
                %             ylabel(sprintf('P(significant \\beta_{%s})',capitalize(coeff_str)));
                %
                %             % reference lines
                %             plot(xlim,[1,1]*0,':k');
                %             plot(xlim,[1,1]*min(alphas),':k');
                %             plot(xlim,[1,1]*max(alphas),':k');
                
                % preallocation
                P = nan(n_epochs,n_alphas);
                
                % iterate through alphas
                for aa = 1 : n_alphas
                    
                    % iterate through epochs
                    for ee = 1 : n_epochs
                        epoch = epochs{ee};
                        P(ee,aa) = sum(...
                            fractions.(glm_str).(epoch).(coeff_lbl)(rr,aa,:));
                    end
                    
                    % plot sign-agnostic proportion through epochs
                    stairs(1:n_epochs,P(:,aa),...
                        'color',stim_clrs(bb,:),...
                        'linewidth',1.5,...
                        'linestyle',repmat('-',1,1+(alphas(aa)==max(alphas))));
                end
            end
            
            % save figure
            if want2save
                svg_file = fullfile(panel_path,[fig.Name,'.svg']);
                print(fig,svg_file,'-dsvg','-painters');
            end
        end
    end
end